; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\devlib.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\devlib.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=494 -I../sdk/1.50/include/ -I../inc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -D__KEIL_MDK__ -D__LPB100__ --enum_is_int --omf_browse=.\output\devlib.crf ..\src\DevLib.c]
                          THUMB

                          AREA ||i.AnalyTime||, CODE, READONLY, ALIGN=2

                  AnalyTime PROC
;;;269    *******************************************************************************/ 
;;;270    extern uint32_t AnalyTime(char *pBuf)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;271    { 
000004  b093              SUB      sp,sp,#0x4c
000006  4605              MOV      r5,r0
;;;272        uint8_t     iPos = 0; 
000008  f04f0800          MOV      r8,#0
;;;273        uint8_t     iTemp; 
;;;274        char        *pCharTem   = pBuf; 
00000c  462f              MOV      r7,r5
;;;275        int         iTime[6+1]  = {0}; 
00000e  211c              MOVS     r1,#0x1c
000010  a80c              ADD      r0,sp,#0x30
000012  f7fffffe          BL       __aeabi_memclr4
;;;276        int         *pArr; 
;;;277        
;;;278        struct tm   TempTime; 
;;;279        time_t      LocalSecond; 
;;;280        
;;;281        // 
;;;282        pArr     = &iTime[0]; 
000016  ac0c              ADD      r4,sp,#0x30
;;;283        // 
;;;284        for(iTemp=0; iTemp<6; iTemp++) 
000018  2600              MOVS     r6,#0
00001a  e00f              B        |L1.60|
                  |L1.28|
;;;285        { 
;;;286            iPos      = strcspn(pCharTem,"-,:;\""); 
00001c  a11d              ADR      r1,|L1.148|
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       strcspn
000024  f00008ff          AND      r8,r0,#0xff
;;;287            *pArr     = atoi(pCharTem); 
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       atoi
00002e  6020              STR      r0,[r4,#0]
;;;288            
;;;289            pArr++; 
000030  1d24              ADDS     r4,r4,#4
;;;290            pCharTem += iPos+1; 
000032  f1080001          ADD      r0,r8,#1
000036  4407              ADD      r7,r7,r0
000038  1c70              ADDS     r0,r6,#1              ;284
00003a  b2c6              UXTB     r6,r0                 ;284
                  |L1.60|
00003c  2e06              CMP      r6,#6                 ;284
00003e  dbed              BLT      |L1.28|
;;;291        } 
;;;292        pArr              = &iTime[6];
000040  ac12              ADD      r4,sp,#0x48
;;;293        TempTime.tm_sec   = *(--pArr);                                              // 设置时间 
000042  1f20              SUBS     r0,r4,#4
000044  4604              MOV      r4,r0
000046  6800              LDR      r0,[r0,#0]
000048  9001              STR      r0,[sp,#4]
;;;294        TempTime.tm_min   = *(--pArr);
00004a  1f20              SUBS     r0,r4,#4
00004c  4604              MOV      r4,r0
00004e  6800              LDR      r0,[r0,#0]
000050  9002              STR      r0,[sp,#8]
;;;295        TempTime.tm_hour  = *(--pArr);
000052  1f20              SUBS     r0,r4,#4
000054  4604              MOV      r4,r0
000056  6800              LDR      r0,[r0,#0]
000058  9003              STR      r0,[sp,#0xc]
;;;296        TempTime.tm_mday  = *(--pArr);
00005a  1f20              SUBS     r0,r4,#4
00005c  4604              MOV      r4,r0
00005e  6800              LDR      r0,[r0,#0]
000060  9004              STR      r0,[sp,#0x10]
;;;297        TempTime.tm_mon   = *(--pArr);
000062  1f20              SUBS     r0,r4,#4
000064  4604              MOV      r4,r0
000066  6800              LDR      r0,[r0,#0]
000068  9005              STR      r0,[sp,#0x14]
;;;298        TempTime.tm_year  = *(--pArr);
00006a  1f20              SUBS     r0,r4,#4
00006c  4604              MOV      r4,r0
00006e  6800              LDR      r0,[r0,#0]
000070  9006              STR      r0,[sp,#0x18]
;;;299        TempTime.tm_isdst = 0;                                                      // 冬令时 
000072  2000              MOVS     r0,#0
000074  9009              STR      r0,[sp,#0x24]
;;;300        
;;;301        // 
;;;302    	TempTime.tm_year -= 1900; 
000076  9806              LDR      r0,[sp,#0x18]
000078  f2a0706c          SUB      r0,r0,#0x76c
00007c  9006              STR      r0,[sp,#0x18]
;;;303        TempTime.tm_mon  -= 1;
00007e  9805              LDR      r0,[sp,#0x14]
000080  1e40              SUBS     r0,r0,#1
000082  9005              STR      r0,[sp,#0x14]
;;;304        LocalSecond       = mktime(&TempTime); 
000084  a801              ADD      r0,sp,#4
000086  f7fffffe          BL       mktime
00008a  4681              MOV      r9,r0
;;;305        
;;;306        return LocalSecond; 
00008c  4648              MOV      r0,r9
;;;307    } 
00008e  b013              ADD      sp,sp,#0x4c
000090  e8bd83f0          POP      {r4-r9,pc}
;;;308    /******************************************************************************* 
                          ENDP

                  |L1.148|
000094  2d2c3a3b          DCB      "-,:;""",0
000098  2200    
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.CaculateUartDataCheckSum||, CODE, READONLY, ALIGN=1

                  CaculateUartDataCheckSum PROC
;;;723    *******************************************************************************/ 
;;;724    extern uint8_t CaculateUartDataCheckSum(uint8_t *pBuf, uint8_t iLen)
000000  b510              PUSH     {r4,lr}
;;;725    { 
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;726        uint8_t i; 
;;;727        uint8_t CheckSum; 
;;;728        
;;;729        CheckSum = 1; 
000006  2001              MOVS     r0,#1
;;;730        for(i=0; i<iLen; i++) 
000008  2100              MOVS     r1,#0
00000a  e004              B        |L2.22|
                  |L2.12|
;;;731        { 
;;;732            CheckSum += *(pBuf+i); 
00000c  5c54              LDRB     r4,[r2,r1]
00000e  4404              ADD      r4,r4,r0
000010  b2e0              UXTB     r0,r4
000012  1c4c              ADDS     r4,r1,#1              ;730
000014  b2e1              UXTB     r1,r4                 ;730
                  |L2.22|
000016  4299              CMP      r1,r3                 ;730
000018  dbf8              BLT      |L2.12|
;;;733        } 
;;;734        return CheckSum; 
;;;735    } 
00001a  bd10              POP      {r4,pc}
;;;736    
                          ENDP


                          AREA ||i.DecodeUrl||, CODE, READONLY, ALIGN=1

                  DecodeUrl PROC
;;;743    *******************************************************************************/ 
;;;744    extern void DecodeUrl(char *pBuf)
000000  2100              MOVS     r1,#0
;;;745    {
;;;746        uint16_t i=0;
;;;747        while(*(pBuf+i))
000002  e02e              B        |L3.98|
                  |L3.4|
;;;748        {
;;;749            if ((*pBuf=*(pBuf+i)) == '%')
000004  5c42              LDRB     r2,[r0,r1]
000006  7002              STRB     r2,[r0,#0]
000008  2a25              CMP      r2,#0x25
00000a  d124              BNE      |L3.86|
;;;750            {
;;;751                *pBuf  = *(pBuf+i+1) >= 'A' ? ((*(pBuf+i+1) & 0xDF) - 'A') + 10 : (*(pBuf+i+1) - '0');
00000c  1842              ADDS     r2,r0,r1
00000e  7852              LDRB     r2,[r2,#1]
000010  2a41              CMP      r2,#0x41
000012  db05              BLT      |L3.32|
000014  1842              ADDS     r2,r0,r1
000016  7852              LDRB     r2,[r2,#1]
000018  f00202df          AND      r2,r2,#0xdf
00001c  3a37              SUBS     r2,r2,#0x37
00001e  e002              B        |L3.38|
                  |L3.32|
000020  1842              ADDS     r2,r0,r1
000022  7852              LDRB     r2,[r2,#1]
000024  3a30              SUBS     r2,r2,#0x30
                  |L3.38|
000026  7002              STRB     r2,[r0,#0]
;;;752                *pBuf  = (*pBuf) * 16;
000028  7802              LDRB     r2,[r0,#0]
00002a  0712              LSLS     r2,r2,#28
00002c  0e12              LSRS     r2,r2,#24
00002e  7002              STRB     r2,[r0,#0]
;;;753                *pBuf += *(pBuf+i+2) >= 'A' ? ((*(pBuf+i+2) & 0xDF) - 'A') + 10 : (*(pBuf+i+2) - '0');
000030  7803              LDRB     r3,[r0,#0]
000032  1842              ADDS     r2,r0,r1
000034  7892              LDRB     r2,[r2,#2]
000036  2a41              CMP      r2,#0x41
000038  db05              BLT      |L3.70|
00003a  1842              ADDS     r2,r0,r1
00003c  7892              LDRB     r2,[r2,#2]
00003e  f00202df          AND      r2,r2,#0xdf
000042  3a37              SUBS     r2,r2,#0x37
000044  e002              B        |L3.76|
                  |L3.70|
000046  1842              ADDS     r2,r0,r1
000048  7892              LDRB     r2,[r2,#2]
00004a  3a30              SUBS     r2,r2,#0x30
                  |L3.76|
00004c  441a              ADD      r2,r2,r3
00004e  7002              STRB     r2,[r0,#0]
;;;754                i  += 2;
000050  1c8a              ADDS     r2,r1,#2
000052  b291              UXTH     r1,r2
000054  e004              B        |L3.96|
                  |L3.86|
;;;755            }
;;;756            else if (*(pBuf+i)=='+')
000056  5c42              LDRB     r2,[r0,r1]
000058  2a2b              CMP      r2,#0x2b
00005a  d101              BNE      |L3.96|
;;;757            {
;;;758                *pBuf  = ' ';
00005c  2220              MOVS     r2,#0x20
00005e  7002              STRB     r2,[r0,#0]
                  |L3.96|
;;;759            }
;;;760            pBuf++;
000060  1c40              ADDS     r0,r0,#1
                  |L3.98|
000062  5c42              LDRB     r2,[r0,r1]            ;747
000064  2a00              CMP      r2,#0                 ;747
000066  d1cd              BNE      |L3.4|
;;;761        }
;;;762        *pBuf = '\0';
000068  7002              STRB     r2,[r0,#0]
;;;763    }
00006a  4770              BX       lr
;;;764    /*******************************************************************************
                          ENDP


                          AREA ||i.DeleteRule||, CODE, READONLY, ALIGN=2

                  DeleteRule PROC
;;;618    *******************************************************************************/
;;;619    extern uint8_t DeleteRule(uint32_t ruleID) 
000000  b570              PUSH     {r4-r6,lr}
;;;620    {
000002  4606              MOV      r6,r0
;;;621        uint8_t i = 0,j = 0;
000004  2400              MOVS     r4,#0
000006  2500              MOVS     r5,#0
;;;622        
;;;623        for(i=0;i<DevRuleInfoObj.RuleCount;i++)
000008  bf00              NOP      
00000a  e022              B        |L4.82|
                  |L4.12|
;;;624        {
;;;625            if(DevRuleInfoObj.SwitchRulePool[i].RuleID == ruleID)
00000c  4814              LDR      r0,|L4.96|
00000e  eb001044          ADD      r0,r0,r4,LSL #5
000012  69c0              LDR      r0,[r0,#0x1c]
000014  42b0              CMP      r0,r6
000016  d11a              BNE      |L4.78|
;;;626            {
;;;627                for(j=i;j<DevRuleInfoObj.RuleCount;j++)
000018  4625              MOV      r5,r4
00001a  e00a              B        |L4.50|
                  |L4.28|
;;;628                {
;;;629                    DevRuleInfoObj.SwitchRulePool[j] = DevRuleInfoObj.SwitchRulePool[j+1];
00001c  4a10              LDR      r2,|L4.96|
00001e  1c6b              ADDS     r3,r5,#1
000020  eb021143          ADD      r1,r2,r3,LSL #5
000024  eb021045          ADD      r0,r2,r5,LSL #5
000028  2220              MOVS     r2,#0x20
00002a  f7fffffe          BL       __aeabi_memcpy4
00002e  1c68              ADDS     r0,r5,#1              ;627
000030  b2c5              UXTB     r5,r0                 ;627
                  |L4.50|
000032  480b              LDR      r0,|L4.96|
000034  3808              SUBS     r0,r0,#8              ;627
000036  7800              LDRB     r0,[r0,#0]            ;627  ; DevRuleInfoObj
000038  42a8              CMP      r0,r5                 ;627
00003a  dcef              BGT      |L4.28|
;;;630                }
;;;631                
;;;632    		    DevRuleInfoObj.RuleCount--;
00003c  4808              LDR      r0,|L4.96|
00003e  3808              SUBS     r0,r0,#8
000040  7800              LDRB     r0,[r0,#0]  ; DevRuleInfoObj
000042  1e40              SUBS     r0,r0,#1
000044  4906              LDR      r1,|L4.96|
000046  3908              SUBS     r1,r1,#8
000048  7008              STRB     r0,[r1,#0]
;;;633    
;;;634                return 1;
00004a  2001              MOVS     r0,#1
                  |L4.76|
;;;635            }
;;;636        }
;;;637        return 0;
;;;638    }
00004c  bd70              POP      {r4-r6,pc}
                  |L4.78|
00004e  1c60              ADDS     r0,r4,#1              ;623
000050  b2c4              UXTB     r4,r0                 ;623
                  |L4.82|
000052  4803              LDR      r0,|L4.96|
000054  3808              SUBS     r0,r0,#8              ;623
000056  7800              LDRB     r0,[r0,#0]            ;623  ; DevRuleInfoObj
000058  42a0              CMP      r0,r4                 ;623
00005a  dcd7              BGT      |L4.12|
00005c  2000              MOVS     r0,#0                 ;637
00005e  e7f5              B        |L4.76|
;;;639    
                          ENDP

                  |L4.96|
                          DCD      DevRuleInfoObj+0x8

                          AREA ||i.DevGPIO_Init||, CODE, READONLY, ALIGN=2

                  DevGPIO_Init PROC
;;;78     *******************************************************************************/
;;;79     extern void DevGPIO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;80     {
;;;81     	hfgpio_configure_fpin(HFGPIO_SW_KEY_CTL_PIN, HFPIO_PULLUP|HFM_IO_TYPE_INPUT);
000002  490f              LDR      r1,|L5.64|
000004  201d              MOVS     r0,#0x1d
000006  f7fffffe          BL       hfgpio_configure_fpin
;;;82     	hfgpio_configure_fpin(HFGPIO_SW_ON_OFF_CTL_PIN, HFPIO_PULLDOWN|HFM_IO_OUTPUT_0);
00000a  490e              LDR      r1,|L5.68|
00000c  201e              MOVS     r0,#0x1e
00000e  f7fffffe          BL       hfgpio_configure_fpin
;;;83     
;;;84     	
;;;85     #if defined(ZX_DETECT)
;;;86     	if(hfgpio_configure_fpin_interrupt(ZX_INT_CHECK,HFPIO_IT_RISE_EDGE,check_user_zxInt,1)!=HF_SUCCESS)
000012  2301              MOVS     r3,#1
000014  4a0c              LDR      r2,|L5.72|
000016  2180              MOVS     r1,#0x80
000018  2022              MOVS     r0,#0x22
00001a  f7fffffe          BL       hfgpio_configure_fpin_interrupt
00001e  b120              CBZ      r0,|L5.42|
;;;87     	{
;;;88     		u_printf("configure HFGPIO_F_USER_RELOAD fail\n");
000020  a10a              ADR      r1,|L5.76|
000022  200a              MOVS     r0,#0xa
000024  f7fffffe          BL       HF_Debug
                  |L5.40|
;;;89     		return;
;;;90     	}
;;;91     #endif
;;;92     
;;;93     	 
;;;94     	SpiRn8209_Init();
;;;95     
;;;96     	RN8209_Init();
;;;97     
;;;98     	uart_process_init();
;;;99     
;;;100    	KeyTimer_Init();
;;;101    }
000028  bd10              POP      {r4,pc}
                  |L5.42|
00002a  f7fffffe          BL       SpiRn8209_Init
00002e  f7fffffe          BL       RN8209_Init
000032  f7fffffe          BL       uart_process_init
000036  f7fffffe          BL       KeyTimer_Init
00003a  bf00              NOP      
00003c  e7f4              B        |L5.40|
;;;102    
                          ENDP

00003e  0000              DCW      0x0000
                  |L5.64|
                          DCD      0x08000001
                  |L5.68|
                          DCD      0x10000002
                  |L5.72|
                          DCD      check_user_zxInt
                  |L5.76|
00004c  636f6e66          DCB      "configure HFGPIO_F_USER_RELOAD fail\n",0
000050  69677572
000054  65204846
000058  4750494f
00005c  5f465f55
000060  5345525f
000064  52454c4f
000068  41442066
00006c  61696c0a
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.GetDaysInMonth||, CODE, READONLY, ALIGN=2

                  GetDaysInMonth PROC
;;;700    *******************************************************************************/ 
;;;701    extern int GetDaysInMonth(int y, int m)
000000  b570              PUSH     {r4-r6,lr}
;;;702    {
000002  b08c              SUB      sp,sp,#0x30
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;703        int d;
;;;704        int day[]= {31,28,31,30,31,30,31,31,30,31,30,31};
000008  2230              MOVS     r2,#0x30
00000a  4913              LDR      r1,|L6.88|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;705        if (2==m)
000012  2d02              CMP      r5,#2
000014  d119              BNE      |L6.74|
;;;706        {
;;;707            d = ((((0==y%4)&&(0!=y%100))||(0==y%400))?29:28);
000016  4620              MOV      r0,r4
000018  17e1              ASRS     r1,r4,#31
00001a  eb047191          ADD      r1,r4,r1,LSR #30
00001e  1089              ASRS     r1,r1,#2
000020  ebb40181          SUBS     r1,r4,r1,LSL #2
000024  d105              BNE      |L6.50|
000026  2164              MOVS     r1,#0x64
000028  fb94f2f1          SDIV     r2,r4,r1
00002c  fb014112          MLS      r1,r1,r2,r4
000030  b931              CBNZ     r1,|L6.64|
                  |L6.50|
000032  f44f71c8          MOV      r1,#0x190
000036  fb94f2f1          SDIV     r2,r4,r1
00003a  fb014112          MLS      r1,r1,r2,r4
00003e  b909              CBNZ     r1,|L6.68|
                  |L6.64|
000040  211d              MOVS     r1,#0x1d
000042  e000              B        |L6.70|
                  |L6.68|
000044  211c              MOVS     r1,#0x1c
                  |L6.70|
000046  460e              MOV      r6,r1
000048  e002              B        |L6.80|
                  |L6.74|
;;;708        }
;;;709        else
;;;710        {
;;;711            d = day[m-1];
00004a  1e68              SUBS     r0,r5,#1
00004c  f85d6020          LDR      r6,[sp,r0,LSL #2]
                  |L6.80|
;;;712    
;;;713        }
;;;714        return d;
000050  4630              MOV      r0,r6
;;;715    }
000052  b00c              ADD      sp,sp,#0x30
000054  bd70              POP      {r4-r6,pc}
;;;716    
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      ||.constdata||

                          AREA ||i.Increment||, CODE, READONLY, ALIGN=2

                  Increment PROC
;;;590    *******************************************************************************/
;;;591    extern uint8_t Increment(uint32_t ruleID,SwitchRuleType tempRule) 
000000  b40f              PUSH     {r0-r3}
;;;592    {
000002  b570              PUSH     {r4-r6,lr}
000004  4605              MOV      r5,r0
;;;593        uint8_t i = 0;
000006  2400              MOVS     r4,#0
;;;594        
;;;595        for(i=0;i<DevRuleInfoObj.RuleCount;i++)
000008  bf00              NOP      
00000a  e00b              B        |L7.36|
                  |L7.12|
;;;596        {
;;;597            if(DevRuleInfoObj.SwitchRulePool[i].RuleID == ruleID)
00000c  4811              LDR      r0,|L7.84|
00000e  eb001044          ADD      r0,r0,r4,LSL #5
000012  69c0              LDR      r0,[r0,#0x1c]
000014  42a8              CMP      r0,r5
000016  d103              BNE      |L7.32|
;;;598            {
;;;599                return 0;
000018  2000              MOVS     r0,#0
                  |L7.26|
;;;600            }
;;;601        }
;;;602    
;;;603         DevRuleInfoObj.RuleCount++;
;;;604         DevRuleInfoObj.SwitchRulePool[DevRuleInfoObj.RuleCount-1] = tempRule;  
;;;605    
;;;606         return 1;
;;;607    }
00001a  bc70              POP      {r4-r6}
00001c  f85dfb14          LDR      pc,[sp],#0x14
                  |L7.32|
000020  1c60              ADDS     r0,r4,#1              ;595
000022  b2c4              UXTB     r4,r0                 ;595
                  |L7.36|
000024  480b              LDR      r0,|L7.84|
000026  3808              SUBS     r0,r0,#8              ;595
000028  7800              LDRB     r0,[r0,#0]            ;595  ; DevRuleInfoObj
00002a  42a0              CMP      r0,r4                 ;595
00002c  dcee              BGT      |L7.12|
00002e  4809              LDR      r0,|L7.84|
000030  3808              SUBS     r0,r0,#8              ;603
000032  7800              LDRB     r0,[r0,#0]            ;603  ; DevRuleInfoObj
000034  1c40              ADDS     r0,r0,#1              ;603
000036  4907              LDR      r1,|L7.84|
000038  3908              SUBS     r1,r1,#8              ;603
00003a  7008              STRB     r0,[r1,#0]            ;603
00003c  7809              LDRB     r1,[r1,#0]            ;604  ; DevRuleInfoObj
00003e  1e49              SUBS     r1,r1,#1              ;604
000040  4a04              LDR      r2,|L7.84|
000042  eb021041          ADD      r0,r2,r1,LSL #5       ;604
000046  2220              MOVS     r2,#0x20              ;604
000048  a905              ADD      r1,sp,#0x14           ;604
00004a  f7fffffe          BL       __aeabi_memcpy4
00004e  2001              MOVS     r0,#1                 ;606
000050  e7e3              B        |L7.26|
;;;608    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      DevRuleInfoObj+0x8

                          AREA ||i.ParseRule||, CODE, READONLY, ALIGN=2

                  ParseRule PROC
;;;476    *******************************************************************************/
;;;477    extern uint8_t ParseRule(char *pArgBuf) 
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;478    { 
000004  b08f              SUB      sp,sp,#0x3c
000006  4682              MOV      r10,r0
;;;479    	cJSON   *json,*port,*week;
;;;480    	uint32_t  ruleID;
;;;481    
;;;482    	uint8_t  iRet,port_num,j,mode;
;;;483    	SwitchRuleType  tempRule;
;;;484    
;;;485    	//u_printf("rule data is:%s\n",pArgBuf);
;;;486    	
;;;487    	json = cJSON_Parse(pArgBuf);
000008  4650              MOV      r0,r10
00000a  f7fffffe          BL       cJSON_Parse
00000e  4607              MOV      r7,r0
;;;488    	iRet = FAILED; 
000010  f04f0801          MOV      r8,#1
;;;489    	if(json)
000014  2f00              CMP      r7,#0
000016  d079              BEQ      |L8.268|
;;;490    	{
;;;491    		memset((char*)&tempRule, 0, sizeof(tempRule));
000018  2120              MOVS     r1,#0x20
00001a  a806              ADD      r0,sp,#0x18
00001c  f7fffffe          BL       __aeabi_memclr4
;;;492    		
;;;493    		mode      = cJSON_GetObjectItem(json, "mode")->valueint;
000020  a151              ADR      r1,|L8.360|
000022  4638              MOV      r0,r7
000024  f7fffffe          BL       cJSON_GetObjectItem
000028  7d06              LDRB     r6,[r0,#0x14]
;;;494    		ruleID    = cJSON_GetObjectItem(json, "id")->valueint;
00002a  a151              ADR      r1,|L8.368|
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       cJSON_GetObjectItem
000032  6945              LDR      r5,[r0,#0x14]
;;;495    		tempRule.RuleID = ruleID;
000034  950d              STR      r5,[sp,#0x34]
;;;496    		tempRule.RuleEnable = cJSON_GetObjectItem(json, "en")->valueint;
000036  a14f              ADR      r1,|L8.372|
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       cJSON_GetObjectItem
00003e  7d00              LDRB     r0,[r0,#0x14]
000040  b240              SXTB     r0,r0
000042  f88d0018          STRB     r0,[sp,#0x18]
;;;497    		tempRule.CurTimeStamp= cJSON_GetObjectItem(json, "day")->valueint;
000046  a14c              ADR      r1,|L8.376|
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       cJSON_GetObjectItem
00004e  6940              LDR      r0,[r0,#0x14]
000050  900a              STR      r0,[sp,#0x28]
;;;498    		
;;;499    		if(tempRule.CurTimeStamp > 0)
000052  980a              LDR      r0,[sp,#0x28]
000054  b158              CBZ      r0,|L8.110|
;;;500    		{
;;;501    		    tempRule.timeStamp = tempRule.CurTimeStamp - (DevInfoObj.TimeZone-12)*3600;
000056  4849              LDR      r0,|L8.380|
000058  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
00005c  380c              SUBS     r0,r0,#0xc
00005e  ebc01240          RSB      r2,r0,r0,LSL #5
000062  ebc22000          RSB      r0,r2,r0,LSL #8
000066  990a              LDR      r1,[sp,#0x28]
000068  eba11000          SUB      r0,r1,r0,LSL #4
00006c  9009              STR      r0,[sp,#0x24]
                  |L8.110|
;;;502    		}
;;;503            //u_printf("timeStamp = %d    DevTimeObj.CurTimeSec=%d\n",tempRule.timeStamp,DevTimeObj.CurTimeSec);
;;;504        
;;;505    		tempRule.timeLong   = cJSON_GetObjectItem(json, "time")->valueint;
00006e  a144              ADR      r1,|L8.384|
000070  4638              MOV      r0,r7
000072  f7fffffe          BL       cJSON_GetObjectItem
000076  6940              LDR      r0,[r0,#0x14]
000078  900b              STR      r0,[sp,#0x2c]
;;;506    		if(tempRule.timeLong == 0)
00007a  980b              LDR      r0,[sp,#0x2c]
00007c  b910              CBNZ     r0,|L8.132|
;;;507    		{
;;;508    			tempRule.exeTimeLong = 1;
00007e  2001              MOVS     r0,#1
000080  900c              STR      r0,[sp,#0x30]
000082  e001              B        |L8.136|
                  |L8.132|
;;;509    		}
;;;510    		else
;;;511    		{
;;;512    			tempRule.exeTimeLong = tempRule.timeLong;
000084  980b              LDR      r0,[sp,#0x2c]
000086  900c              STR      r0,[sp,#0x30]
                  |L8.136|
;;;513    		}
;;;514    		
;;;515    		port        = cJSON_GetObjectItem(json, "port");
000088  a13f              ADR      r1,|L8.392|
00008a  4638              MOV      r0,r7
00008c  f7fffffe          BL       cJSON_GetObjectItem
000090  4683              MOV      r11,r0
;;;516    		port_num    = cJSON_GetArraySize(port);		
000092  4658              MOV      r0,r11
000094  f7fffffe          BL       cJSON_GetArraySize
000098  f00009ff          AND      r9,r0,#0xff
;;;517    		for(j=0; j<port_num; j++)
00009c  2400              MOVS     r4,#0
00009e  e009              B        |L8.180|
                  |L8.160|
;;;518    		{
;;;519    			tempRule.PortArr[j] = cJSON_GetArrayItem(port, j)->valueint;
0000a0  4621              MOV      r1,r4
0000a2  4658              MOV      r0,r11
0000a4  f7fffffe          BL       cJSON_GetArrayItem
0000a8  7d01              LDRB     r1,[r0,#0x14]
0000aa  f10d001a          ADD      r0,sp,#0x1a
0000ae  5501              STRB     r1,[r0,r4]
0000b0  1c60              ADDS     r0,r4,#1              ;517
0000b2  b2c4              UXTB     r4,r0                 ;517
                  |L8.180|
0000b4  454c              CMP      r4,r9                 ;517
0000b6  dbf3              BLT      |L8.160|
;;;520    			//u_printf("port[%d] = %d\n",ruleID,cJSON_GetArrayItem(port,j)->valueint);
;;;521    	    }
;;;522    	    
;;;523    	    week   = cJSON_GetObjectItem(json, "week");
0000b8  a135              ADR      r1,|L8.400|
0000ba  4638              MOV      r0,r7
0000bc  f7fffffe          BL       cJSON_GetObjectItem
0000c0  900e              STR      r0,[sp,#0x38]
;;;524    		for(j=0; j<DAY_COUNT_OF_WEEK; j++)
0000c2  2400              MOVS     r4,#0
0000c4  e00d              B        |L8.226|
                  |L8.198|
;;;525    		{
;;;526    			tempRule.SwOpDateObj |= ((cJSON_GetArrayItem(week,j)->valueint)<<j);
0000c6  4621              MOV      r1,r4
0000c8  980e              LDR      r0,[sp,#0x38]
0000ca  f7fffffe          BL       cJSON_GetArrayItem
0000ce  7d00              LDRB     r0,[r0,#0x14]
0000d0  40a0              LSLS     r0,r0,r4
0000d2  f89d1019          LDRB     r1,[sp,#0x19]
0000d6  4308              ORRS     r0,r0,r1
0000d8  b2c0              UXTB     r0,r0
0000da  f88d0019          STRB     r0,[sp,#0x19]
0000de  1c60              ADDS     r0,r4,#1              ;524
0000e0  b2c4              UXTB     r4,r0                 ;524
                  |L8.226|
0000e2  2c07              CMP      r4,#7                 ;524
0000e4  dbef              BLT      |L8.198|
;;;527    			
;;;528    			//u_printf("rule[%d]:day[%d] = %d\n",ruleID,j,cJSON_GetArrayItem(week,j)->valueint);
;;;529    		}
;;;530            
;;;531    		if(mode == 0)                //添加规则
0000e6  b996              CBNZ     r6,|L8.270|
;;;532    		{  
;;;533    		    if(DevRuleInfoObj.RuleCount < SOCKET_RULE_COUNT)
0000e8  482b              LDR      r0,|L8.408|
0000ea  7800              LDRB     r0,[r0,#0]  ; DevRuleInfoObj
0000ec  280c              CMP      r0,#0xc
0000ee  da28              BGE      |L8.322|
;;;534    		    {	
;;;535    	            if(Increment(ruleID,tempRule))
0000f0  2214              MOVS     r2,#0x14
0000f2  a909              ADD      r1,sp,#0x24
0000f4  4668              MOV      r0,sp
0000f6  f7fffffe          BL       __aeabi_memcpy4
0000fa  4628              MOV      r0,r5
0000fc  a906              ADD      r1,sp,#0x18
0000fe  c90e              LDM      r1,{r1-r3}
000100  f7fffffe          BL       Increment
000104  b1e8              CBZ      r0,|L8.322|
;;;536    	            {
;;;537    	                iRet = PASSED;
000106  f04f0800          MOV      r8,#0
00010a  e01a              B        |L8.322|
                  |L8.268|
00010c  e028              B        |L8.352|
                  |L8.270|
;;;538    	            }
;;;539    	            
;;;540    		        //PrintRule();
;;;541    		    }
;;;542    		}
;;;543    		else if(mode == 2)           //删除规则
00010e  2e02              CMP      r6,#2
000110  d10a              BNE      |L8.296|
;;;544    		{
;;;545    		    //u_printf("Delete ruleID is :%d\n",ruleID);
;;;546    		    
;;;547    		    if(DevRuleInfoObj.RuleCount>0)
000112  4821              LDR      r0,|L8.408|
000114  7800              LDRB     r0,[r0,#0]  ; DevRuleInfoObj
000116  2800              CMP      r0,#0
000118  dd13              BLE      |L8.322|
;;;548    		    {
;;;549    		        if(DeleteRule(ruleID))
00011a  4628              MOV      r0,r5
00011c  f7fffffe          BL       DeleteRule
000120  b178              CBZ      r0,|L8.322|
;;;550    		        {
;;;551    		            iRet = PASSED;
000122  f04f0800          MOV      r8,#0
000126  e00c              B        |L8.322|
                  |L8.296|
;;;552    		        }
;;;553    		        
;;;554    		        //PrintRule();
;;;555    		    }
;;;556    		}
;;;557    		else                       //编辑规则
;;;558    		{
;;;559    		    if(ReFreshRule(ruleID,tempRule))
000128  2214              MOVS     r2,#0x14
00012a  a909              ADD      r1,sp,#0x24
00012c  4668              MOV      r0,sp
00012e  f7fffffe          BL       __aeabi_memcpy4
000132  4628              MOV      r0,r5
000134  a906              ADD      r1,sp,#0x18
000136  c90e              LDM      r1,{r1-r3}
000138  f7fffffe          BL       ReFreshRule
00013c  b108              CBZ      r0,|L8.322|
;;;560    		    {
;;;561    		        iRet = PASSED;
00013e  f04f0800          MOV      r8,#0
                  |L8.322|
;;;562    		    }
;;;563    		    
;;;564    		    //PrintRule();
;;;565    		}
;;;566    
;;;567    		cJSON_Delete(json);
000142  4638              MOV      r0,r7
000144  f7fffffe          BL       cJSON_Delete
;;;568    
;;;569    		
;;;570    		if(iRet == PASSED)
000148  f1b80f00          CMP      r8,#0
00014c  d108              BNE      |L8.352|
;;;571    		{ 
;;;572                SetBit(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_13_RULE_IS_DIRTY_CMD);
00014e  4813              LDR      r0,|L8.412|
000150  6800              LDR      r0,[r0,#0]  ; FwUpdateStatusObj
000152  f4405000          ORR      r0,r0,#0x2000
000156  4911              LDR      r1,|L8.412|
000158  6008              STR      r0,[r1,#0]  ; FwUpdateStatusObj
;;;573                DevRuleInfoObj.isRuleSaveFlag = FLASH_DEV_RULE_FLAG;
00015a  4811              LDR      r0,|L8.416|
00015c  490e              LDR      r1,|L8.408|
00015e  6048              STR      r0,[r1,#4]  ; DevRuleInfoObj
                  |L8.352|
;;;574            }
;;;575    
;;;576    //		PublicServer_SyncBaseInfoWithServer();
;;;577        }
;;;578        return iRet; 
000160  4640              MOV      r0,r8
;;;579    } 
000162  b00f              ADD      sp,sp,#0x3c
000164  e8bd8ff0          POP      {r4-r11,pc}
;;;580    
                          ENDP

                  |L8.360|
000168  6d6f6465          DCB      "mode",0
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0
                  |L8.368|
000170  696400            DCB      "id",0
000173  00                DCB      0
                  |L8.372|
000174  656e00            DCB      "en",0
000177  00                DCB      0
                  |L8.376|
000178  64617900          DCB      "day",0
                  |L8.380|
                          DCD      DevInfoObj
                  |L8.384|
000180  74696d65          DCB      "time",0
000184  00      
000185  00                DCB      0
000186  00                DCB      0
000187  00                DCB      0
                  |L8.392|
000188  706f7274          DCB      "port",0
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L8.400|
000190  7765656b          DCB      "week",0
000194  00      
000195  00                DCB      0
000196  00                DCB      0
000197  00                DCB      0
                  |L8.408|
                          DCD      DevRuleInfoObj
                  |L8.412|
                          DCD      FwUpdateStatusObj
                  |L8.416|
                          DCD      0x33553355

                          AREA ||i.ReFreshRule||, CODE, READONLY, ALIGN=2

                  ReFreshRule PROC
;;;648    *******************************************************************************/
;;;649    extern uint8_t ReFreshRule(uint32_t ruleID,SwitchRuleType tempRule) 
000000  b40f              PUSH     {r0-r3}
;;;650    {
000002  b570              PUSH     {r4-r6,lr}
000004  4605              MOV      r5,r0
;;;651        uint8_t i = 0;
000006  2400              MOVS     r4,#0
;;;652        
;;;653        for(i=0;i<DevRuleInfoObj.RuleCount;i++)
000008  bf00              NOP      
00000a  e012              B        |L9.50|
                  |L9.12|
;;;654        {
;;;655            if(DevRuleInfoObj.SwitchRulePool[i].RuleID == ruleID)
00000c  480c              LDR      r0,|L9.64|
00000e  eb001044          ADD      r0,r0,r4,LSL #5
000012  69c0              LDR      r0,[r0,#0x1c]
000014  42a8              CMP      r0,r5
000016  d10a              BNE      |L9.46|
;;;656            {
;;;657                  DevRuleInfoObj.SwitchRulePool[i] = tempRule;
000018  4909              LDR      r1,|L9.64|
00001a  eb011044          ADD      r0,r1,r4,LSL #5
00001e  2220              MOVS     r2,#0x20
000020  a905              ADD      r1,sp,#0x14
000022  f7fffffe          BL       __aeabi_memcpy4
;;;658    
;;;659                  return 1;
000026  2001              MOVS     r0,#1
                  |L9.40|
;;;660            }   
;;;661        }
;;;662    
;;;663        return 0;
;;;664    }
000028  bc70              POP      {r4-r6}
00002a  f85dfb14          LDR      pc,[sp],#0x14
                  |L9.46|
00002e  1c60              ADDS     r0,r4,#1              ;653
000030  b2c4              UXTB     r4,r0                 ;653
                  |L9.50|
000032  4803              LDR      r0,|L9.64|
000034  3808              SUBS     r0,r0,#8              ;653
000036  7800              LDRB     r0,[r0,#0]            ;653  ; DevRuleInfoObj
000038  42a0              CMP      r0,r4                 ;653
00003a  dce7              BGT      |L9.12|
00003c  2000              MOVS     r0,#0                 ;663
00003e  e7f3              B        |L9.40|
;;;665    
                          ENDP

                  |L9.64|
                          DCD      DevRuleInfoObj+0x8

                          AREA ||i.Reboot||, CODE, READONLY, ALIGN=2

                  Reboot PROC
;;;253    *******************************************************************************/ 
;;;254    extern void Reboot(int iRebootCode)
000000  f0000103          AND      r1,r0,#3
;;;255    {
;;;256        FwUpdateStatusObj.SyncRebootCode  = (iRebootCode&CMD_VALID_MASK); 
000004  4a04              LDR      r2,|L10.24|
000006  71d1              STRB     r1,[r2,#7]
;;;257        FwUpdateStatusObj.RebootCountDown = 5; 
000008  2105              MOVS     r1,#5
00000a  7191              STRB     r1,[r2,#6]
;;;258        SetBit(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_6_IS_REBOOT_CMD);
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]  ; FwUpdateStatusObj
000010  f0410140          ORR      r1,r1,#0x40
000014  6011              STR      r1,[r2,#0]  ; FwUpdateStatusObj
;;;259    }
000016  4770              BX       lr
;;;260    
                          ENDP

                  |L10.24|
                          DCD      FwUpdateStatusObj

                          AREA ||i.RebootSyncDev||, CODE, READONLY, ALIGN=2

                  RebootSyncDev PROC
;;;222    #define     CMD_VALID_MASK          0x03 
;;;223    char RebootSyncDev(char *pBufData,int *cmd) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;224    { 
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;225        cJSON   *pJson; 
;;;226        char    iRet; 
;;;227    
;;;228        u_printf("Reset cmd is:%s\n",pBufData);
000008  462a              MOV      r2,r5
00000a  a112              ADR      r1,|L11.84|
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       HF_Debug
;;;229        
;;;230        iRet  = 1; 
000012  2701              MOVS     r7,#1
;;;231        pJson = cJSON_Parse(pBufData); 
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       cJSON_Parse
00001a  4606              MOV      r6,r0
;;;232        if(pJson) 
00001c  b1b6              CBZ      r6,|L11.76|
;;;233        { 
;;;234            *cmd  = cJSON_GetObjectItem(pJson, "op")->valueint; 
00001e  a112              ADR      r1,|L11.104|
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       cJSON_GetObjectItem
000026  6940              LDR      r0,[r0,#0x14]
000028  6020              STR      r0,[r4,#0]
;;;235            cJSON_Delete(pJson); 
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       cJSON_Delete
;;;236            if(CMD_VALID_MASK != (*cmd&CMD_VALID_MASK)) 
000030  7820              LDRB     r0,[r4,#0]
000032  f0000003          AND      r0,r0,#3
000036  2803              CMP      r0,#3
000038  d003              BEQ      |L11.66|
;;;237            { 
;;;238                Reboot(*cmd);
00003a  6820              LDR      r0,[r4,#0]
00003c  f7fffffe          BL       Reboot
;;;239                iRet = 0; 
000040  2700              MOVS     r7,#0
                  |L11.66|
;;;240            } 
;;;241    
;;;242            u_printf("cmd = %d\n",*cmd);
000042  a10a              ADR      r1,|L11.108|
000044  200a              MOVS     r0,#0xa
000046  6822              LDR      r2,[r4,#0]
000048  f7fffffe          BL       HF_Debug
                  |L11.76|
;;;243        } 
;;;244        return iRet;
00004c  4638              MOV      r0,r7
;;;245    } 
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;246    
                          ENDP

000052  0000              DCW      0x0000
                  |L11.84|
000054  52657365          DCB      "Reset cmd is:%s\n",0
000058  7420636d
00005c  64206973
000060  3a25730a
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L11.104|
000068  6f7000            DCB      "op",0
00006b  00                DCB      0
                  |L11.108|
00006c  636d6420          DCB      "cmd = %d\n",0
000070  3d202564
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.SetCurTime||, CODE, READONLY, ALIGN=2

                  SetCurTime PROC
;;;317    extern  DevTimeType                 DevTimeObj;
;;;318    extern char SetCurTime(char *pBuf)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;319    { 
000004  b093              SUB      sp,sp,#0x4c
000006  4680              MOV      r8,r0
;;;320        uint8_t     iPos = 0; 
000008  f04f0900          MOV      r9,#0
;;;321        uint8_t     iTemp; 
;;;322        char        *pCharTem   = pBuf; 
00000c  4646              MOV      r6,r8
;;;323        int         iTime[6+1]  = {0}; 
00000e  211c              MOVS     r1,#0x1c
000010  a80c              ADD      r0,sp,#0x30
000012  f7fffffe          BL       __aeabi_memclr4
;;;324        int         *pArr; 
;;;325        
;;;326        //static      uint8_t  CurHaveSetTime = CUR_NOT_SET_TIME;                     // 记录本地是否设置过时间,本地设置过时间则不再接受服务器时间 
;;;327        
;;;328        struct tm   TempTime, *pTime; 
;;;329        time_t      LocalCurSecond; 
;;;330        
;;;331        // 
;;;332        pArr     = &iTime[0]; 
000016  ad0c              ADD      r5,sp,#0x30
;;;333        // 
;;;334        for(iTemp=0; iTemp<6; iTemp++) 
000018  2400              MOVS     r4,#0
00001a  e00f              B        |L12.60|
                  |L12.28|
;;;335        { 
;;;336            iPos      = strcspn(pCharTem,"-,:;\""); 
00001c  a15f              ADR      r1,|L12.412|
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       strcspn
000024  f00009ff          AND      r9,r0,#0xff
;;;337            *pArr     = atoi(pCharTem); 
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       atoi
00002e  6028              STR      r0,[r5,#0]
;;;338            pArr++; 
000030  1d2d              ADDS     r5,r5,#4
;;;339            pCharTem += iPos+1; 
000032  f1090001          ADD      r0,r9,#1
000036  4406              ADD      r6,r6,r0
000038  1c60              ADDS     r0,r4,#1              ;334
00003a  b2c4              UXTB     r4,r0                 ;334
                  |L12.60|
00003c  2c06              CMP      r4,#6                 ;334
00003e  dbed              BLT      |L12.28|
;;;340        } 
;;;341        pArr              = &iTime[6];
000040  ad12              ADD      r5,sp,#0x48
;;;342        TempTime.tm_sec   = *(--pArr);                                              // 设置时间 
000042  1f28              SUBS     r0,r5,#4
000044  4605              MOV      r5,r0
000046  6800              LDR      r0,[r0,#0]
000048  9001              STR      r0,[sp,#4]
;;;343        TempTime.tm_min   = *(--pArr);
00004a  1f28              SUBS     r0,r5,#4
00004c  4605              MOV      r5,r0
00004e  6800              LDR      r0,[r0,#0]
000050  9002              STR      r0,[sp,#8]
;;;344        TempTime.tm_hour  = *(--pArr);
000052  1f28              SUBS     r0,r5,#4
000054  4605              MOV      r5,r0
000056  6800              LDR      r0,[r0,#0]
000058  9003              STR      r0,[sp,#0xc]
;;;345        TempTime.tm_mday  = *(--pArr);
00005a  1f28              SUBS     r0,r5,#4
00005c  4605              MOV      r5,r0
00005e  6800              LDR      r0,[r0,#0]
000060  9004              STR      r0,[sp,#0x10]
;;;346        TempTime.tm_mon   = *(--pArr);
000062  1f28              SUBS     r0,r5,#4
000064  4605              MOV      r5,r0
000066  6800              LDR      r0,[r0,#0]
000068  9005              STR      r0,[sp,#0x14]
;;;347        TempTime.tm_year  = *(--pArr);
00006a  1f28              SUBS     r0,r5,#4
00006c  4605              MOV      r5,r0
00006e  6800              LDR      r0,[r0,#0]
000070  9006              STR      r0,[sp,#0x18]
;;;348        TempTime.tm_isdst = 0;                                                      // 冬令时 
000072  2000              MOVS     r0,#0
000074  9009              STR      r0,[sp,#0x24]
;;;349      
;;;350        pCharTem --; 
000076  1e76              SUBS     r6,r6,#1
;;;351        if(',' == *pCharTem)                                                        // 接收时间为本地时间 
000078  7830              LDRB     r0,[r6,#0]
00007a  282c              CMP      r0,#0x2c
00007c  d11b              BNE      |L12.182|
;;;352        { 
;;;353            //if(CUR_HAD_SET_TIME == CurHaveSetTime)
;;;354            {
;;;355            //    return 0;
;;;356            }
;;;357            pCharTem ++;                                                            // 
00007e  1c76              ADDS     r6,r6,#1
;;;358            iTemp     = atoi(pCharTem);
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       atoi
000086  b2c4              UXTB     r4,r0
;;;359    
;;;360            //u_printf("TimeZone=%d   getTimeZone=%d\n",DevInfoObj.TimeZone,iTemp);
;;;361            
;;;362            if(DevInfoObj.TimeZone != iTemp)
000088  4846              LDR      r0,|L12.420|
00008a  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
00008e  42a0              CMP      r0,r4
000090  d004              BEQ      |L12.156|
;;;363            {
;;;364                DevInfoObj.TimeZone = iTemp;                                        // 
000092  4844              LDR      r0,|L12.420|
000094  f880403a          STRB     r4,[r0,#0x3a]
;;;365                WriteDevTimeZone();                                           // Save Current Time Zone To flash  
000098  f7fffffe          BL       WriteDevTimeZone
                  |L12.156|
;;;366            }
;;;367            
;;;368            //CurHaveSetTime   = CUR_HAD_SET_TIME;                                 // 
;;;369        	TempTime.tm_year-= 1900;
00009c  9806              LDR      r0,[sp,#0x18]
00009e  f2a0706c          SUB      r0,r0,#0x76c
0000a2  9006              STR      r0,[sp,#0x18]
;;;370            TempTime.tm_mon -= 1;
0000a4  9805              LDR      r0,[sp,#0x14]
0000a6  1e40              SUBS     r0,r0,#1
0000a8  9005              STR      r0,[sp,#0x14]
;;;371            pTime            = &TempTime; 
0000aa  af01              ADD      r7,sp,#4
;;;372            LocalCurSecond   = mktime(&TempTime);                                   //        
0000ac  a801              ADD      r0,sp,#4
0000ae  f7fffffe          BL       mktime
0000b2  9000              STR      r0,[sp,#0]
0000b4  e02f              B        |L12.278|
                  |L12.182|
;;;373        } 
;;;374        else                                                 // 接收时间为UTC时间 ( 则根据本地时区来进行调整 ) 
;;;375        { 
;;;376    	    TempTime.tm_year -= 1900; 
0000b6  9806              LDR      r0,[sp,#0x18]
0000b8  f2a0706c          SUB      r0,r0,#0x76c
0000bc  9006              STR      r0,[sp,#0x18]
;;;377            TempTime.tm_mon  -= 1; 
0000be  9805              LDR      r0,[sp,#0x14]
0000c0  1e40              SUBS     r0,r0,#1
0000c2  9005              STR      r0,[sp,#0x14]
;;;378            LocalCurSecond    = mktime(&TempTime); 
0000c4  a801              ADD      r0,sp,#4
0000c6  f7fffffe          BL       mktime
0000ca  9000              STR      r0,[sp,#0]
;;;379            if(DevInfoObj.TimeZone>12) 
0000cc  4835              LDR      r0,|L12.420|
0000ce  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
0000d2  280c              CMP      r0,#0xc
0000d4  dd0d              BLE      |L12.242|
;;;380            { 
;;;381                iTemp           = DevInfoObj.TimeZone - 12; 
0000d6  4833              LDR      r0,|L12.420|
0000d8  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
0000dc  380c              SUBS     r0,r0,#0xc
0000de  b2c4              UXTB     r4,r0
;;;382                LocalCurSecond += iTemp * 3600; 
0000e0  ebc41044          RSB      r0,r4,r4,LSL #5
0000e4  ebc02004          RSB      r0,r0,r4,LSL #8
0000e8  9900              LDR      r1,[sp,#0]
0000ea  eb011000          ADD      r0,r1,r0,LSL #4
0000ee  9000              STR      r0,[sp,#0]
0000f0  e00d              B        |L12.270|
                  |L12.242|
;;;383            } 
;;;384            else 
;;;385            { 
;;;386                iTemp           = 12 - DevInfoObj.TimeZone; 
0000f2  482c              LDR      r0,|L12.420|
0000f4  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
0000f8  f1c0000c          RSB      r0,r0,#0xc
0000fc  b2c4              UXTB     r4,r0
;;;387                LocalCurSecond -= iTemp * 3600; 
0000fe  ebc41044          RSB      r0,r4,r4,LSL #5
000102  ebc02004          RSB      r0,r0,r4,LSL #8
000106  9900              LDR      r1,[sp,#0]
000108  eba11000          SUB      r0,r1,r0,LSL #4
00010c  9000              STR      r0,[sp,#0]
                  |L12.270|
;;;388            } 
;;;389            pTime = localtime(&LocalCurSecond);
00010e  4668              MOV      r0,sp
000110  f7fffffe          BL       localtime
000114  4607              MOV      r7,r0
                  |L12.278|
;;;390        }
;;;391    
;;;392        DevInfoObj.isCalibrateTime = 0x01;
000116  2001              MOVS     r0,#1
000118  4922              LDR      r1,|L12.420|
00011a  f8810040          STRB     r0,[r1,#0x40]
;;;393        
;;;394      
;;;395       
;;;396       #if defined(__UDP_SET_TIME_DBG__) && defined(__UDP_PRINT_DBG__) 
;;;397        UdpDebugPrint("SetTime\r\n", sizeof("SetTime\r\n")-1);
;;;398       #endif 
;;;399    
;;;400        DevTimeObj.CurTimeSec         = LocalCurSecond; 
00011e  4922              LDR      r1,|L12.424|
000120  9800              LDR      r0,[sp,#0]
000122  6308              STR      r0,[r1,#0x30]  ; DevTimeObj
;;;401        if(DevInfoObj.TimeZone>12) 
000124  481f              LDR      r0,|L12.420|
000126  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
00012a  280c              CMP      r0,#0xc
00012c  dd0f              BLE      |L12.334|
;;;402        { 
;;;403            iTemp           = DevInfoObj.TimeZone - 12; 
00012e  481d              LDR      r0,|L12.420|
000130  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
000134  380c              SUBS     r0,r0,#0xc
000136  b2c4              UXTB     r4,r0
;;;404            DevTimeObj.NowTimeSec = DevTimeObj.CurTimeSec - iTemp * 3600; 
000138  4608              MOV      r0,r1
00013a  6b00              LDR      r0,[r0,#0x30]  ; DevTimeObj
00013c  ebc41144          RSB      r1,r4,r4,LSL #5
000140  ebc12104          RSB      r1,r1,r4,LSL #8
000144  eba01001          SUB      r0,r0,r1,LSL #4
000148  4917              LDR      r1,|L12.424|
00014a  62c8              STR      r0,[r1,#0x2c]  ; DevTimeObj
00014c  e00f              B        |L12.366|
                  |L12.334|
;;;405        } 
;;;406        else 
;;;407        { 
;;;408            iTemp           = 12 - DevInfoObj.TimeZone; 
00014e  4815              LDR      r0,|L12.420|
000150  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
000154  f1c0000c          RSB      r0,r0,#0xc
000158  b2c4              UXTB     r4,r0
;;;409            DevTimeObj.NowTimeSec = DevTimeObj.CurTimeSec + iTemp * 3600;  
00015a  4813              LDR      r0,|L12.424|
00015c  6b00              LDR      r0,[r0,#0x30]  ; DevTimeObj
00015e  ebc41144          RSB      r1,r4,r4,LSL #5
000162  ebc12104          RSB      r1,r1,r4,LSL #8
000166  eb001001          ADD      r0,r0,r1,LSL #4
00016a  490f              LDR      r1,|L12.424|
00016c  62c8              STR      r0,[r1,#0x2c]  ; DevTimeObj
                  |L12.366|
;;;410        }    
;;;411        DevTimeObj.NowTimeTm          = *pTime; 
00016e  222c              MOVS     r2,#0x2c
000170  4639              MOV      r1,r7
000172  480d              LDR      r0,|L12.424|
000174  f7fffffe          BL       __aeabi_memcpy4
;;;412        DevTimeObj.NowTimeTm.tm_year += 1900; 
000178  480b              LDR      r0,|L12.424|
00017a  6940              LDR      r0,[r0,#0x14]  ; DevTimeObj
00017c  f200706c          ADD      r0,r0,#0x76c
000180  4909              LDR      r1,|L12.424|
000182  6148              STR      r0,[r1,#0x14]  ; DevTimeObj
;;;413        DevTimeObj.NowTimeTm.tm_mon++; 
000184  4608              MOV      r0,r1
000186  6900              LDR      r0,[r0,#0x10]  ; DevTimeObj
000188  1c40              ADDS     r0,r0,#1
00018a  6108              STR      r0,[r1,#0x10]  ; DevTimeObj
;;;414      
;;;415       #if  defined(__DS1302_RTC_ENABLE__)  
;;;416        set_rtctime(pTime); 
00018c  4638              MOV      r0,r7
00018e  f7fffffe          BL       set_rtctime
;;;417       #else 
;;;418        SysTime_Set(pTime); 
;;;419       #endif 
;;;420    
;;;421        
;;;422        return 0; 
000192  2000              MOVS     r0,#0
;;;423    } 
000194  b013              ADD      sp,sp,#0x4c
000196  e8bd83f0          POP      {r4-r9,pc}
;;;424    
                          ENDP

00019a  0000              DCW      0x0000
                  |L12.412|
00019c  2d2c3a3b          DCB      "-,:;""",0
0001a0  2200    
0001a2  00                DCB      0
0001a3  00                DCB      0
                  |L12.420|
                          DCD      DevInfoObj
                  |L12.424|
                          DCD      DevTimeObj

                          AREA ||i.SetCurTimeFromSec||, CODE, READONLY, ALIGN=2

                  SetCurTimeFromSec PROC
;;;433    *******************************************************************************/ 
;;;434    extern void SetCurTimeFromSec(time_t timeStack)
000000  b570              PUSH     {r4-r6,lr}
;;;435    {
000002  4604              MOV      r4,r0
;;;436        struct tm  *pTime;
;;;437        uint8_t     iTemp; 
;;;438    
;;;439        DevTimeObj.NowTimeSec         = timeStack; 
000004  481a              LDR      r0,|L13.112|
000006  62c4              STR      r4,[r0,#0x2c]  ; DevTimeObj
;;;440        
;;;441        if(DevInfoObj.TimeZone>12) 
000008  481a              LDR      r0,|L13.116|
00000a  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
00000e  280c              CMP      r0,#0xc
000010  dd0d              BLE      |L13.46|
;;;442        { 
;;;443            iTemp           = DevInfoObj.TimeZone - 12; 
000012  4818              LDR      r0,|L13.116|
000014  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
000018  380c              SUBS     r0,r0,#0xc
00001a  b2c5              UXTB     r5,r0
;;;444            timeStack += iTemp * 3600; 
00001c  ebc51045          RSB      r0,r5,r5,LSL #5
000020  ebc02005          RSB      r0,r0,r5,LSL #8
000024  eb041400          ADD      r4,r4,r0,LSL #4
;;;445            DevTimeObj.CurTimeSec = timeStack;
000028  4811              LDR      r0,|L13.112|
00002a  6304              STR      r4,[r0,#0x30]  ; DevTimeObj
00002c  e00d              B        |L13.74|
                  |L13.46|
;;;446        } 
;;;447        else 
;;;448        { 
;;;449            iTemp           = 12 - DevInfoObj.TimeZone; 
00002e  4811              LDR      r0,|L13.116|
000030  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
000034  f1c0000c          RSB      r0,r0,#0xc
000038  b2c5              UXTB     r5,r0
;;;450            timeStack       -= iTemp * 3600; 
00003a  ebc51045          RSB      r0,r5,r5,LSL #5
00003e  ebc02005          RSB      r0,r0,r5,LSL #8
000042  eba41400          SUB      r4,r4,r0,LSL #4
;;;451            DevTimeObj.CurTimeSec = timeStack;
000046  480a              LDR      r0,|L13.112|
000048  6304              STR      r4,[r0,#0x30]  ; DevTimeObj
                  |L13.74|
;;;452        } 
;;;453        
;;;454        pTime = localtime(&DevTimeObj.CurTimeSec);
00004a  4809              LDR      r0,|L13.112|
00004c  3030              ADDS     r0,r0,#0x30
00004e  f7fffffe          BL       localtime
000052  4606              MOV      r6,r0
;;;455       #if  defined(__DS1302_RTC_ENABLE__)  
;;;456        DevTimeObj.NowTimeTm          = *pTime; 
000054  222c              MOVS     r2,#0x2c
000056  4631              MOV      r1,r6
000058  4805              LDR      r0,|L13.112|
00005a  f7fffffe          BL       __aeabi_memcpy4
;;;457    //    DevTimeObj.NowTimeTm.tm_year += 1900; 
;;;458    //    DevTimeObj.NowTimeTm.tm_mon++; 
;;;459        set_rtctime(pTime); 
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       set_rtctime
;;;460       #else 
;;;461        SysTime_Set(pTime); 
;;;462       #endif 
;;;463    
;;;464       DevInfoObj.isCalibrateTime = 0x01;
000064  2001              MOVS     r0,#1
000066  4903              LDR      r1,|L13.116|
000068  f8810040          STRB     r0,[r1,#0x40]
;;;465    
;;;466       //u_printf("isCalibrateTime = %d   RecordEndTime=%d\n",DevInfoObj.isCalibrateTime,RecordEndTime);
;;;467    }
00006c  bd70              POP      {r4-r6,pc}
;;;468    
                          ENDP

00006e  0000              DCW      0x0000
                  |L13.112|
                          DCD      DevTimeObj
                  |L13.116|
                          DCD      DevInfoObj

                          AREA ||i.SetUpdateUrl||, CODE, READONLY, ALIGN=2

                          REQUIRE _scanf_int
                  SetUpdateUrl PROC
;;;160    *******************************************************************************/ 
;;;161    extern uint8_t SetUpdateUrl(char *pDataBuf)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;162    { 
000004  4681              MOV      r9,r0
;;;163    	cJSON       *json; 
;;;164    	char        *str; 
;;;165    	int         iLength, iRet, FwNewVer[2]={0}; 
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  9001              STR      r0,[sp,#4]
;;;166    	uint8_t     iRslt;
;;;167    	uint16_t    PublicVer;
;;;168        // 
;;;169        #if defined(__URL_UPDATE_DBG__) && defined(__UDP_PRINT_DBG__)
;;;170        UdpDebugPrint("51 UpdateUrl:\r\n", sizeof("51 UpdateUrl:\r\n")-1);
;;;171        #endif
;;;172        iRslt = 1;
00000c  f04f0a01          MOV      r10,#1
;;;173    	json  = cJSON_Parse(pDataBuf);
000010  4648              MOV      r0,r9
000012  f7fffffe          BL       cJSON_Parse
000016  4607              MOV      r7,r0
;;;174    	if(json)
000018  2f00              CMP      r7,#0
00001a  d05b              BEQ      |L14.212|
;;;175        {
;;;176    		str  = cJSON_GetObjectItem(json, "ver")->valuestring; 
00001c  a12f              ADR      r1,|L14.220|
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       cJSON_GetObjectItem
000024  6904              LDR      r4,[r0,#0x10]
;;;177            if(str) 
000026  2c00              CMP      r4,#0
000028  d051              BEQ      |L14.206|
;;;178            { 
;;;179                iRet = sscanf(str, "%d.%d", &FwNewVer[0],&FwNewVer[1]); 
00002a  ab01              ADD      r3,sp,#4
00002c  466a              MOV      r2,sp
00002e  a12c              ADR      r1,|L14.224|
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       __0sscanf
000036  4606              MOV      r6,r0
;;;180                if(-1 != iRet) 
000038  f1b63fff          CMP      r6,#0xffffffff
00003c  d047              BEQ      |L14.206|
;;;181                { 
;;;182                    FwUpdateObj.PublicServerVer.big_ver    = FwNewVer[0]; 
00003e  492a              LDR      r1,|L14.232|
000040  9800              LDR      r0,[sp,#0]
000042  6048              STR      r0,[r1,#4]  ; FwUpdateObj
;;;183                    FwUpdateObj.PublicServerVer.little_ver = FwNewVer[1]; 
000044  4828              LDR      r0,|L14.232|
000046  9901              LDR      r1,[sp,#4]
000048  6081              STR      r1,[r0,#8]
;;;184                    PublicVer = (((FwNewVer[0]<<8)&0xFF00) | (FwNewVer[1]&0xff));
00004a  f44f417f          MOV      r1,#0xff00
00004e  9800              LDR      r0,[sp,#0]
000050  ea012000          AND      r0,r1,r0,LSL #8
000054  9901              LDR      r1,[sp,#4]
000056  b2c9              UXTB     r1,r1
000058  ea400801          ORR      r8,r0,r1
;;;185                    if( PublicVer>CURRENT_VER_NUMBER )
00005c  4823              LDR      r0,|L14.236|
00005e  7800              LDRB     r0,[r0,#0]  ; big_version
000060  f44f417f          MOV      r1,#0xff00
000064  ea012000          AND      r0,r1,r0,LSL #8
000068  4921              LDR      r1,|L14.240|
00006a  7809              LDRB     r1,[r1,#0]  ; little_version
00006c  4308              ORRS     r0,r0,r1
00006e  4540              CMP      r0,r8
000070  da2d              BGE      |L14.206|
;;;186                    {
;;;187            		    FwUpdateObj.data_checksum = cJSON_GetObjectItem(json,"checksum")->valueint; 
000072  a120              ADR      r1,|L14.244|
000074  4638              MOV      r0,r7
000076  f7fffffe          BL       cJSON_GetObjectItem
00007a  6940              LDR      r0,[r0,#0x14]
00007c  491a              LDR      r1,|L14.232|
00007e  6108              STR      r0,[r1,#0x10]  ; FwUpdateObj
;;;188                    	str     = cJSON_GetObjectItem(json,"url")->valuestring;
000080  a11f              ADR      r1,|L14.256|
000082  4638              MOV      r0,r7
000084  f7fffffe          BL       cJSON_GetObjectItem
000088  6904              LDR      r4,[r0,#0x10]
;;;189                    	iLength = strlen(str); 
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       strlen
000090  4605              MOV      r5,r0
;;;190                    	if(iLength < UPDATE_URL_MAX_LENGTH) 
000092  2dff              CMP      r5,#0xff
000094  da1b              BGE      |L14.206|
;;;191                    	{ 
;;;192                            if(0x00 == hfthread_mutext_trylock(FwUpdateObj.FwUpdateMutx)) 
000096  4914              LDR      r1,|L14.232|
000098  6808              LDR      r0,[r1,#0]  ; FwUpdateObj
00009a  f7fffffe          BL       hfthread_mutext_trylock
00009e  b9b0              CBNZ     r0,|L14.206|
;;;193                            { 
;;;194                                memset(FwUpdateObj.UpdateUrl, '\0', UPDATE_URL_MAX_LENGTH); 
0000a0  21ff              MOVS     r1,#0xff
0000a2  4811              LDR      r0,|L14.232|
0000a4  3014              ADDS     r0,r0,#0x14
0000a6  f7fffffe          BL       __aeabi_memclr4
;;;195                                memcpy(FwUpdateObj.UpdateUrl, str, iLength); 
0000aa  462a              MOV      r2,r5
0000ac  4621              MOV      r1,r4
0000ae  480e              LDR      r0,|L14.232|
0000b0  3014              ADDS     r0,r0,#0x14
0000b2  f7fffffe          BL       __aeabi_memcpy
;;;196                    		    SetBit(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_5_IS_URL_UPDATE_FW); 
0000b6  4813              LDR      r0,|L14.260|
0000b8  6800              LDR      r0,[r0,#0]  ; FwUpdateStatusObj
0000ba  f0400020          ORR      r0,r0,#0x20
0000be  4911              LDR      r1,|L14.260|
0000c0  6008              STR      r0,[r1,#0]  ; FwUpdateStatusObj
;;;197                    		    iRslt = 0; 
0000c2  f04f0a00          MOV      r10,#0
;;;198                                hfthread_mutext_unlock(FwUpdateObj.FwUpdateMutx); 
0000c6  4908              LDR      r1,|L14.232|
0000c8  6808              LDR      r0,[r1,#0]  ; FwUpdateObj
0000ca  f7fffffe          BL       hfthread_mutext_unlock
                  |L14.206|
;;;199                                // 
;;;200                                #if defined(__URL_UPDATE_DBG__) && defined(__UDP_PRINT_DBG__) 
;;;201                                UdpDebugPrint("Record Url:\r\n", sizeof("Record Url:\r\n")-1); 
;;;202                                UdpDebugPrint(FwUpdateObj.UpdateUrl, iLength); 
;;;203                                UdpDebugPrint("\r\n", sizeof("\r\n")-1); 
;;;204                                #endif 
;;;205                            } 
;;;206                    	} 
;;;207                	}
;;;208                } 
;;;209            } 
;;;210    		cJSON_Delete(json); 
0000ce  4638              MOV      r0,r7
0000d0  f7fffffe          BL       cJSON_Delete
                  |L14.212|
;;;211    	} 
;;;212        return iRslt;
0000d4  4650              MOV      r0,r10
;;;213    } 
0000d6  e8bd87fc          POP      {r2-r10,pc}
;;;214    
                          ENDP

0000da  0000              DCW      0x0000
                  |L14.220|
0000dc  76657200          DCB      "ver",0
                  |L14.224|
0000e0  25642e25          DCB      "%d.%d",0
0000e4  6400    
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L14.232|
                          DCD      FwUpdateObj
                  |L14.236|
                          DCD      big_version
                  |L14.240|
                          DCD      little_version
                  |L14.244|
0000f4  63686563          DCB      "checksum",0
0000f8  6b73756d
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L14.256|
000100  75726c00          DCB      "url",0
                  |L14.260|
                          DCD      FwUpdateStatusObj

                          AREA ||i.UdpDebugPrint||, CODE, READONLY, ALIGN=2

                  UdpDebugPrint PROC
;;;123    #if defined(__UDP_PRINT_DBG__) 
;;;124    extern void UdpDebugPrint(char *pArgBuf, int ArgLength) 
000000  b570              PUSH     {r4-r6,lr}
;;;125    { 
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;126        struct sockaddr_in  UdpPrintDebugAddr; 
;;;127        int                 fd; 
;;;128        
;;;129        UdpPrintDebugAddr.sin_family       = AF_INET; 
000008  2002              MOVS     r0,#2
00000a  f88d0009          STRB     r0,[sp,#9]
;;;130        UdpPrintDebugAddr.sin_port         = htons(8892); 
00000e  f24220bc          MOV      r0,#0x22bc
000012  f7fffffe          BL       lwip_htons
000016  f8ad000a          STRH     r0,[sp,#0xa]
;;;131        UdpPrintDebugAddr.sin_addr.s_addr  = inet_addr("255.255.255.255"); 
00001a  a00e              ADR      r0,|L15.84|
00001c  f7fffffe          BL       ipaddr_addr
000020  9003              STR      r0,[sp,#0xc]
;;;132        
;;;133        fd = FwUpdateStatusObj.UdpFd; 
000022  4810              LDR      r0,|L15.100|
000024  6884              LDR      r4,[r0,#8]  ; FwUpdateStatusObj
;;;134        if(-1 == fd) 
000026  f1b43fff          CMP      r4,#0xffffffff
00002a  d106              BNE      |L15.58|
;;;135        { 
;;;136            #if defined(__BSD_SOCKET_UDP_SERVER_ENABLE__) 
;;;137            fd = UdpServerThread_GetSocketFd();
00002c  f7fffffe          BL       UdpServerThread_GetSocketFd
000030  4604              MOV      r4,r0
;;;138            #else 
;;;139            fd = hfnet_socketa_fd(); 
;;;140            #endif 
;;;141            
;;;142            if(fd<0)
000032  2c00              CMP      r4,#0
000034  da01              BGE      |L15.58|
                  |L15.54|
;;;143            { 
;;;144                return; 
;;;145            } 
;;;146        } 
;;;147    
;;;148        sendto( fd, pArgBuf, ArgLength, 0, 
;;;149                (struct sockaddr*)&UdpPrintDebugAddr, 
;;;150                sizeof(struct sockaddr)); 
;;;151    } 
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
                  |L15.58|
00003a  2010              MOVS     r0,#0x10              ;148
00003c  a902              ADD      r1,sp,#8              ;148
00003e  2300              MOVS     r3,#0                 ;148
000040  4632              MOV      r2,r6                 ;148
000042  e9cd1000          STRD     r1,r0,[sp,#0]         ;148
000046  4629              MOV      r1,r5                 ;148
000048  4620              MOV      r0,r4                 ;148
00004a  f7fffffe          BL       lwip_sendto
00004e  bf00              NOP      
000050  e7f1              B        |L15.54|
;;;152    #endif 
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
000054  3235352e          DCB      "255.255.255.255",0
000058  3235352e
00005c  3235352e
000060  32353500
                  |L15.100|
                          DCD      FwUpdateStatusObj

                          AREA ||i.check_user_zxInt||, CODE, READONLY, ALIGN=1

                  check_user_zxInt PROC
;;;110    *******************************************************************************/
;;;111    static void USER_FUNC check_user_zxInt(uint32_t arg1,uint32_t arg2)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;113    	ZX_detect_control();
000006  f7fffffe          BL       ZX_detect_control
;;;114    }
00000a  bd70              POP      {r4-r6,pc}
;;;115    #endif
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=1

                  delay_us PROC
;;;63     *******************************************************************************/ 
;;;64     extern void delay_us(int us)
000000  b508              PUSH     {r3,lr}
;;;65     {
;;;66     	volatile int i;
;;;67     	for(i=0; i<us; i++)
000002  2100              MOVS     r1,#0
000004  9100              STR      r1,[sp,#0]
000006  e002              B        |L17.14|
                  |L17.8|
000008  9900              LDR      r1,[sp,#0]
00000a  1c49              ADDS     r1,r1,#1
00000c  9100              STR      r1,[sp,#0]
                  |L17.14|
00000e  9900              LDR      r1,[sp,#0]
000010  4281              CMP      r1,r0
000012  dbf9              BLT      |L17.8|
;;;68     	{
;;;69     		;
;;;70     	}
;;;71     }
000014  bd08              POP      {r3,pc}
;;;72     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x0000001f
                          DCD      0x0000001c
                          DCD      0x0000001f
                          DCD      0x0000001e
                          DCD      0x0000001f
                          DCD      0x0000001e
                          DCD      0x0000001f
                          DCD      0x0000001f
                          DCD      0x0000001e
                          DCD      0x0000001f
                          DCD      0x0000001e
                          DCD      0x0000001f
