; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\security_mode.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\security_mode.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=494 -I../sdk/1.50/include/ -I../inc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -D__KEIL_MDK__ -D__LPB100__ --enum_is_int --omf_browse=.\output\security_mode.crf ..\src\security_mode.c]
                          THUMB

                          AREA ||i.DevSecurityModePoll||, CODE, READONLY, ALIGN=2

                  DevSecurityModePoll PROC
;;;91     *******************************************************************************/
;;;92     void DevSecurityModePoll(void)
000000  b510              PUSH     {r4,lr}
;;;93     {
;;;94         SecurityModeType  *pSecurityModeObj = NULL; 
000002  2400              MOVS     r4,#0
;;;95     
;;;96     	if(isBitSet(FwUpdateStatusObj.TimelyCheck, TIMELY_DETECTE_BIT_19_DEV_SECURITY_MODE_CMD))
000004  480c              LDR      r0,|L1.56|
000006  6800              LDR      r0,[r0,#0]  ; FwUpdateStatusObj
000008  f4102f00          TST      r0,#0x80000
00000c  d012              BEQ      |L1.52|
;;;97     	{
;;;98     		ClrBit(FwUpdateStatusObj.TimelyCheck, TIMELY_DETECTE_BIT_19_DEV_SECURITY_MODE_CMD);
00000e  480a              LDR      r0,|L1.56|
000010  6800              LDR      r0,[r0,#0]  ; FwUpdateStatusObj
000012  f4202000          BIC      r0,r0,#0x80000
000016  4908              LDR      r1,|L1.56|
000018  6008              STR      r0,[r1,#0]  ; FwUpdateStatusObj
;;;99     		
;;;100    		if(0x00 == DevInfoObj.isCalibrateTime)			//未对时
00001a  4808              LDR      r0,|L1.60|
00001c  f8900040          LDRB     r0,[r0,#0x40]  ; DevInfoObj
000020  b900              CBNZ     r0,|L1.36|
                  |L1.34|
;;;101    		{
;;;102    			return;
;;;103    		}
;;;104    		pSecurityModeObj = &SecurityMode;
;;;105    
;;;106    		if(pSecurityModeObj->enable)
;;;107    		{
;;;108    	        if(0x00 != pSecurityModeObj->SwOpDateObj) 		//周期性有效
;;;109    	        {
;;;110    	            ProduceRotateSecurityMode(pSecurityModeObj);
;;;111    	        }
;;;112    		}
;;;113    	}
;;;114    }
000022  bd10              POP      {r4,pc}
                  |L1.36|
000024  4c06              LDR      r4,|L1.64|
000026  7820              LDRB     r0,[r4,#0]            ;106
000028  b120              CBZ      r0,|L1.52|
00002a  7860              LDRB     r0,[r4,#1]            ;108
00002c  b110              CBZ      r0,|L1.52|
00002e  4620              MOV      r0,r4                 ;110
000030  f7fffffe          BL       ProduceRotateSecurityMode
                  |L1.52|
000034  bf00              NOP      
000036  e7f4              B        |L1.34|
;;;115    
                          ENDP

                  |L1.56|
                          DCD      FwUpdateStatusObj
                  |L1.60|
                          DCD      DevInfoObj
                  |L1.64|
                          DCD      SecurityMode

                          AREA ||i.ParseSecurityMode||, CODE, READONLY, ALIGN=2

                  ParseSecurityMode PROC
;;;41     *******************************************************************************/
;;;42     extern uint8_t ParseSecurityMode(char *pArgBuf) 
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;43     { 
000004  4607              MOV      r7,r0
;;;44     	cJSON   *json,*timeArray,*week,*port;
;;;45     
;;;46     	uint8_t  iRet,j,port_num;
;;;47     
;;;48     	//UdpDebugPrint(pArgBuf,strlen(pArgBuf));
;;;49     	memset((char*)&SecurityMode,0,sizeof(SecurityMode));
000006  2114              MOVS     r1,#0x14
000008  482c              LDR      r0,|L2.188|
00000a  f7fffffe          BL       __aeabi_memclr4
;;;50     	json = cJSON_Parse(pArgBuf);
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       cJSON_Parse
000014  4605              MOV      r5,r0
;;;51     	iRet = FAILED; 
000016  f04f0801          MOV      r8,#1
;;;52     	if(json)
00001a  2d00              CMP      r5,#0
00001c  d04b              BEQ      |L2.182|
;;;53     	{
;;;54     		SecurityMode.enable = cJSON_GetObjectItem(json, "enable")->valueint;
00001e  a128              ADR      r1,|L2.192|
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       cJSON_GetObjectItem
000026  7d00              LDRB     r0,[r0,#0x14]
000028  4924              LDR      r1,|L2.188|
00002a  7008              STRB     r0,[r1,#0]
;;;55     			
;;;56     		timeArray        = cJSON_GetObjectItem(json, "time");			
00002c  a126              ADR      r1,|L2.200|
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       cJSON_GetObjectItem
000034  4681              MOV      r9,r0
;;;57     		SecurityMode.startTime = cJSON_GetArrayItem(timeArray, 0)->valueint;
000036  2100              MOVS     r1,#0
000038  4648              MOV      r0,r9
00003a  f7fffffe          BL       cJSON_GetArrayItem
00003e  8a80              LDRH     r0,[r0,#0x14]
000040  491e              LDR      r1,|L2.188|
000042  8148              STRH     r0,[r1,#0xa]
;;;58     		SecurityMode.endTime = cJSON_GetArrayItem(timeArray, 1)->valueint;
000044  2101              MOVS     r1,#1
000046  4648              MOV      r0,r9
000048  f7fffffe          BL       cJSON_GetArrayItem
00004c  8a80              LDRH     r0,[r0,#0x14]
00004e  491b              LDR      r1,|L2.188|
000050  8188              STRH     r0,[r1,#0xc]
;;;59     
;;;60     		port        = cJSON_GetObjectItem(json, "port");
000052  a11f              ADR      r1,|L2.208|
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       cJSON_GetObjectItem
00005a  4683              MOV      r11,r0
;;;61     		port_num    = cJSON_GetArraySize(port);		
00005c  4658              MOV      r0,r11
00005e  f7fffffe          BL       cJSON_GetArraySize
000062  b2c6              UXTB     r6,r0
;;;62     		for(j=0; j<port_num; j++)
000064  2400              MOVS     r4,#0
000066  e009              B        |L2.124|
                  |L2.104|
;;;63     		{
;;;64     			SecurityMode.PortArr[j] = cJSON_GetArrayItem(port, j)->valueint;
000068  4621              MOV      r1,r4
00006a  4658              MOV      r0,r11
00006c  f7fffffe          BL       cJSON_GetArrayItem
000070  7d01              LDRB     r1,[r0,#0x14]
000072  4812              LDR      r0,|L2.188|
000074  1c80              ADDS     r0,r0,#2
000076  5501              STRB     r1,[r0,r4]
000078  1c60              ADDS     r0,r4,#1              ;62
00007a  b2c4              UXTB     r4,r0                 ;62
                  |L2.124|
00007c  42b4              CMP      r4,r6                 ;62
00007e  dbf3              BLT      |L2.104|
;;;65     			//u_printf("port[%d] = %d\n",ruleID,cJSON_GetArrayItem(port,j)->valueint);
;;;66     	    }
;;;67     
;;;68     		week   = cJSON_GetObjectItem(json, "week");
000080  a115              ADR      r1,|L2.216|
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       cJSON_GetObjectItem
000088  4682              MOV      r10,r0
;;;69     		for(j=0; j<DAY_COUNT_OF_WEEK; j++)
00008a  2400              MOVS     r4,#0
00008c  e00c              B        |L2.168|
                  |L2.142|
;;;70     		{
;;;71     			SecurityMode.SwOpDateObj |= ((cJSON_GetArrayItem(week,j)->valueint)<<j);
00008e  4621              MOV      r1,r4
000090  4650              MOV      r0,r10
000092  f7fffffe          BL       cJSON_GetArrayItem
000096  7d00              LDRB     r0,[r0,#0x14]
000098  40a0              LSLS     r0,r0,r4
00009a  4908              LDR      r1,|L2.188|
00009c  7849              LDRB     r1,[r1,#1]  ; SecurityMode
00009e  4308              ORRS     r0,r0,r1
0000a0  4906              LDR      r1,|L2.188|
0000a2  7048              STRB     r0,[r1,#1]
0000a4  1c60              ADDS     r0,r4,#1              ;69
0000a6  b2c4              UXTB     r4,r0                 ;69
                  |L2.168|
0000a8  2c07              CMP      r4,#7                 ;69
0000aa  dbf0              BLT      |L2.142|
;;;72     			
;;;73     			//u_printf("rule[%d]:day[%d] = %d\n",ruleID,j,cJSON_GetArrayItem(week,j)->valueint);
;;;74     		}
;;;75     		
;;;76     
;;;77     		iRet = PASSED;
0000ac  f04f0800          MOV      r8,#0
;;;78     		cJSON_Delete(json);
0000b0  4628              MOV      r0,r5
0000b2  f7fffffe          BL       cJSON_Delete
                  |L2.182|
;;;79         }
;;;80         return iRet; 
0000b6  4640              MOV      r0,r8
;;;81     } 
0000b8  e8bd9ff0          POP      {r4-r12,pc}
;;;82     
                          ENDP

                  |L2.188|
                          DCD      SecurityMode
                  |L2.192|
0000c0  656e6162          DCB      "enable",0
0000c4  6c6500  
0000c7  00                DCB      0
                  |L2.200|
0000c8  74696d65          DCB      "time",0
0000cc  00      
0000cd  00                DCB      0
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L2.208|
0000d0  706f7274          DCB      "port",0
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L2.216|
0000d8  7765656b          DCB      "week",0
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0

                          AREA ||i.ProduceRotateSecurityMode||, CODE, READONLY, ALIGN=2

                  ProduceRotateSecurityMode PROC
;;;125    **********************************************************************************************************/
;;;126    static void ProduceRotateSecurityMode(SecurityModeType  *pSecurityModeObj)
000000  b570              PUSH     {r4-r6,lr}
;;;127    {
000002  4604              MOV      r4,r0
;;;128        uint8_t     iTmp;
;;;129        uint32_t    NowTimeMin;
;;;130    	//static uint8_t autoMode = 0;			//自动警戒模式
;;;131    	//char testBuf[100] = {0};
;;;132    
;;;133        NowTimeMin = DevTimeObj.NowTimeTm.tm_hour * 60 + DevTimeObj.NowTimeTm.tm_min; 
000004  482f              LDR      r0,|L3.196|
000006  6840              LDR      r0,[r0,#4]  ; DevTimeObj
000008  492e              LDR      r1,|L3.196|
00000a  6889              LDR      r1,[r1,#8]  ; DevTimeObj
00000c  ebc11101          RSB      r1,r1,r1,LSL #4
000010  eb000581          ADD      r5,r0,r1,LSL #2
;;;134        iTmp       = DevTimeObj.NowTimeTm.tm_wday; 							//星期几
000014  482b              LDR      r0,|L3.196|
000016  7e06              LDRB     r6,[r0,#0x18]  ; DevTimeObj
;;;135    
;;;136    	srand(DevTimeObj.NowTimeSec);
000018  4601              MOV      r1,r0
00001a  6ac8              LDR      r0,[r1,#0x2c]  ; DevTimeObj
00001c  f7fffffe          BL       srand
;;;137    
;;;138    	if(!SecurityModeExcute.RunningMark)
000020  4829              LDR      r0,|L3.200|
000022  7880              LDRB     r0,[r0,#2]  ; SecurityModeExcute
000024  bbc8              CBNZ     r0,|L3.154|
;;;139    	{
;;;140    		if(isBitSet(pSecurityModeObj->SwOpDateObj,iTmp))
000026  7860              LDRB     r0,[r4,#1]
000028  2101              MOVS     r1,#1
00002a  40b1              LSLS     r1,r1,r6
00002c  4208              TST      r0,r1
00002e  d048              BEQ      |L3.194|
;;;141    		{
;;;142    			if(pSecurityModeObj->startTime < (pSecurityModeObj->endTime-20))		//取20分钟的随机值
000030  8961              LDRH     r1,[r4,#0xa]
000032  89a0              LDRH     r0,[r4,#0xc]
000034  3814              SUBS     r0,r0,#0x14
000036  4281              CMP      r1,r0
000038  da18              BGE      |L3.108|
;;;143    			{
;;;144    		        if(NowTimeMin>=pSecurityModeObj->startTime && NowTimeMin<(pSecurityModeObj->endTime-20))
00003a  8960              LDRH     r0,[r4,#0xa]
00003c  42a8              CMP      r0,r5
00003e  d840              BHI      |L3.194|
000040  89a0              LDRH     r0,[r4,#0xc]
000042  3814              SUBS     r0,r0,#0x14
000044  42a8              CMP      r0,r5
000046  d93c              BLS      |L3.194|
;;;145    		        {
;;;146    					SecurityModeExcute.intervalTime = pSecurityModeObj->endTime - NowTimeMin;
000048  89a0              LDRH     r0,[r4,#0xc]
00004a  1b40              SUBS     r0,r0,r5
00004c  b200              SXTH     r0,r0
00004e  491e              LDR      r1,|L3.200|
000050  8088              STRH     r0,[r1,#4]
;;;147    					SecurityModeExcute.RunningMark = 1;				//警戒模式开始执行
000052  2001              MOVS     r0,#1
000054  7088              STRB     r0,[r1,#2]
;;;148    					SecurityModeExcute.nextIntervalTime = rand()%10+10;
000056  f7fffffe          BL       rand
00005a  210a              MOVS     r1,#0xa
00005c  fb90f2f1          SDIV     r2,r0,r1
000060  fb010012          MLS      r0,r1,r2,r0
000064  300a              ADDS     r0,r0,#0xa
000066  4918              LDR      r1,|L3.200|
000068  7048              STRB     r0,[r1,#1]
00006a  e02a              B        |L3.194|
                  |L3.108|
;;;149    		        }
;;;150    			}
;;;151    			else
;;;152    			{
;;;153    				if(NowTimeMin>=pSecurityModeObj->startTime)
00006c  8960              LDRH     r0,[r4,#0xa]
00006e  42a8              CMP      r0,r5
000070  d827              BHI      |L3.194|
;;;154    		        {							
;;;155    					SecurityModeExcute.intervalTime = pSecurityModeObj->endTime+24*60 - NowTimeMin;
000072  89a0              LDRH     r0,[r4,#0xc]
000074  f50060b4          ADD      r0,r0,#0x5a0
000078  1b40              SUBS     r0,r0,r5
00007a  b200              SXTH     r0,r0
00007c  4912              LDR      r1,|L3.200|
00007e  8088              STRH     r0,[r1,#4]
;;;156    					SecurityModeExcute.RunningMark = 1;				//警戒模式开始执行
000080  2001              MOVS     r0,#1
000082  7088              STRB     r0,[r1,#2]
;;;157    					SecurityModeExcute.nextIntervalTime = rand()%10+10;
000084  f7fffffe          BL       rand
000088  210a              MOVS     r1,#0xa
00008a  fb90f2f1          SDIV     r2,r0,r1
00008e  fb010012          MLS      r0,r1,r2,r0
000092  300a              ADDS     r0,r0,#0xa
000094  490c              LDR      r1,|L3.200|
000096  7048              STRB     r0,[r1,#1]
000098  e013              B        |L3.194|
                  |L3.154|
00009a  e7ff              B        |L3.156|
                  |L3.156|
;;;158    				#if 0
;;;159    					memset(testBuf,0,sizeof(testBuf));
;;;160    					sprintf(testBuf,"intervalTime=%d\t NowTimeMin=%d\t endTime=%d\n",
;;;161    						SecurityModeExcute.intervalTime,NowTimeMin,pSecurityModeObj->endTime);
;;;162    					UdpDebugPrint(testBuf,sizeof(testBuf));
;;;163    				#endif
;;;164    		        }
;;;165    			}
;;;166    		}
;;;167    	}
;;;168    	else
;;;169        {	
;;;170    	#if 0
;;;171    		memset(testBuf,0,sizeof(testBuf));
;;;172    		sprintf(testBuf,"intervalTime=%d\t RunningMark=%d\t nextIntervalTime=%d\n",
;;;173    			SecurityModeExcute.intervalTime,SecurityModeExcute.RunningMark,SecurityModeExcute.nextIntervalTime);
;;;174    		UdpDebugPrint(testBuf,sizeof(testBuf));
;;;175    	#endif
;;;176    		
;;;177    		if(SecurityModeExcute.timeOut)
00009c  480a              LDR      r0,|L3.200|
00009e  7800              LDRB     r0,[r0,#0]  ; SecurityModeExcute
0000a0  b178              CBZ      r0,|L3.194|
;;;178    		{
;;;179    			SecurityModeExcute.timeOut = 0;
0000a2  2000              MOVS     r0,#0
0000a4  4908              LDR      r1,|L3.200|
0000a6  7008              STRB     r0,[r1,#0]
;;;180    			//执行开关跳变
;;;181    			SwitchTurnOver(pSecurityModeObj);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       SwitchTurnOver
;;;182    			//计算下一次跳边距离现在的分钟数
;;;183    			
;;;184    			SecurityModeExcute.nextIntervalTime = rand()%10+10;
0000ae  f7fffffe          BL       rand
0000b2  210a              MOVS     r1,#0xa
0000b4  fb90f2f1          SDIV     r2,r0,r1
0000b8  fb010012          MLS      r0,r1,r2,r0
0000bc  300a              ADDS     r0,r0,#0xa
0000be  4902              LDR      r1,|L3.200|
0000c0  7048              STRB     r0,[r1,#1]
                  |L3.194|
;;;185    			
;;;186           		//sprintf(testBuf,"Now reset next security time:nextIntervalTime=%d\n",SecurityModeExcute.nextIntervalTime);
;;;187    			//UdpDebugPrint(testBuf,sizeof(testBuf));
;;;188    		}
;;;189        }
;;;190    }
0000c2  bd70              POP      {r4-r6,pc}
;;;191    
                          ENDP

                  |L3.196|
                          DCD      DevTimeObj
                  |L3.200|
                          DCD      SecurityModeExcute

                          AREA ||i.SwitchTurnOver||, CODE, READONLY, ALIGN=2

                  SwitchTurnOver PROC
;;;200    **********************************************************************************************************/
;;;201    static void SwitchTurnOver(SecurityModeType  *pSecurityModeObj)
000000  b570              PUSH     {r4-r6,lr}
;;;202    {
000002  4605              MOV      r5,r0
;;;203        uint8_t iTmp;
;;;204        iTmp = 0;
000004  2400              MOVS     r4,#0
;;;205      
;;;206      #if(PORT_NUM == 6)
;;;207      {
;;;208        while((iTmp<PORT_NUM))
000006  e017              B        |L4.56|
                  |L4.8|
;;;209        {
;;;210            if(pSecurityModeObj->PortArr[iTmp]==1)
000008  1ca8              ADDS     r0,r5,#2
00000a  5d00              LDRB     r0,[r0,r4]
00000c  2801              CMP      r0,#1
00000e  d111              BNE      |L4.52|
;;;211            {
;;;212    			if(SwInformation.PortInfor[iTmp].OnOffStatus)
000010  eb040184          ADD      r1,r4,r4,LSL #2
000014  480c              LDR      r0,|L4.72|
000016  eb000081          ADD      r0,r0,r1,LSL #2
00001a  7c40              LDRB     r0,[r0,#0x11]
00001c  b128              CBZ      r0,|L4.42|
;;;213    	        {
;;;214    	            SetPortState(iTmp+1,0);            
00001e  1c61              ADDS     r1,r4,#1
000020  b2c8              UXTB     r0,r1
000022  2100              MOVS     r1,#0
000024  f7fffffe          BL       SetPortState
000028  e004              B        |L4.52|
                  |L4.42|
;;;215    	        }
;;;216    	        else 
;;;217    	        {
;;;218    	            SetPortState(iTmp+1,1);
00002a  1c61              ADDS     r1,r4,#1
00002c  b2c8              UXTB     r0,r1
00002e  2101              MOVS     r1,#1
000030  f7fffffe          BL       SetPortState
                  |L4.52|
;;;219    	        }
;;;220        	}
;;;221    	
;;;222            iTmp++;
000034  1c60              ADDS     r0,r4,#1
000036  b2c4              UXTB     r4,r0
                  |L4.56|
000038  2c06              CMP      r4,#6                 ;208
00003a  dbe5              BLT      |L4.8|
;;;223        }  
;;;224    	msleep(200);
00003c  20c8              MOVS     r0,#0xc8
00003e  f7fffffe          BL       hf_thread_delay
;;;225        UsartControlPortOnOff(); 
000042  f7fffffe          BL       UsartControlPortOnOff
;;;226      }
;;;227      #elif (PORT_NUM == 1)
;;;228      {
;;;229        if(pSecurityModeObj->PortArr[iTmp]==1)			//翻转对应的IO口
;;;230        {
;;;231    		if(SwInformation.PortInfor[0].OnOffStatus)
;;;232    		{
;;;233            	Port_TurnOnOff(0);
;;;234    		}
;;;235    		else
;;;236    		{
;;;237            	Port_TurnOnOff(1);
;;;238    		}
;;;239    		
;;;240    		plug_updata = 1;
;;;241         }
;;;242      }
;;;243      #endif
;;;244    
;;;245      //UdpDebugPrint("Now excute OnOffSwitch,DevRule.c 150 line!\r\n",sizeof("Now excute OnOffSwitch,DevRule.c 150 line!\r\n")-1);
;;;246    }
000046  bd70              POP      {r4-r6,pc}
;;;247    
                          ENDP

                  |L4.72|
                          DCD      SwInformation+0x8

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  SecurityMode
                          %        20

                          AREA ||.data||, DATA, ALIGN=1

                  securityStatus
000000  00                DCB      0x00
                  reportSecurityInfo
000001  01                DCB      0x01
                  SecurityModeExcute
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000
