; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\produce_test.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\produce_test.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=494 -I../sdk/1.50/include/ -I../inc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -D__KEIL_MDK__ -D__LPB100__ --enum_is_int --omf_browse=.\output\produce_test.crf ..\src\Produce_Test.c]
                          THUMB

                          AREA ||i.IfOrderControl||, CODE, READONLY, ALIGN=2

                  IfOrderControl PROC
;;;410    *******************************************************************************/
;;;411    bool IfOrderControl()
000000  4807              LDR      r0,|L1.32|
;;;412    {
;;;413    
;;;414        if(orderArray[0].OrderMark || orderArray[1].OrderMark || orderArray[3].OrderMark || orderArray[4].OrderMark)
000002  7800              LDRB     r0,[r0,#0]  ; orderArray
000004  b940              CBNZ     r0,|L1.24|
000006  4806              LDR      r0,|L1.32|
000008  78c0              LDRB     r0,[r0,#3]  ; orderArray
00000a  b928              CBNZ     r0,|L1.24|
00000c  4804              LDR      r0,|L1.32|
00000e  7a40              LDRB     r0,[r0,#9]  ; orderArray
000010  b910              CBNZ     r0,|L1.24|
000012  4803              LDR      r0,|L1.32|
000014  7b00              LDRB     r0,[r0,#0xc]  ; orderArray
000016  b108              CBZ      r0,|L1.28|
                  |L1.24|
;;;415        {
;;;416            return true;
000018  2001              MOVS     r0,#1
                  |L1.26|
;;;417        }
;;;418        else
;;;419        {
;;;420            return false;
;;;421        }
;;;422        
;;;423    }
00001a  4770              BX       lr
                  |L1.28|
00001c  2000              MOVS     r0,#0                 ;420
00001e  e7fc              B        |L1.26|
;;;424    
                          ENDP

                  |L1.32|
                          DCD      orderArray

                          AREA ||i.OrderResend||, CODE, READONLY, ALIGN=1

                  OrderResend PROC
;;;340    *******************************************************************************/
;;;341    void OrderResend(char cmd)
000000  b510              PUSH     {r4,lr}
;;;342    {
000002  4604              MOV      r4,r0
;;;343    
;;;344        if(0xAA == (int)cmd)
000004  2caa              CMP      r4,#0xaa
000006  d100              BNE      |L2.10|
;;;345        {
;;;346            cmd = 0x00;
000008  2400              MOVS     r4,#0
                  |L2.10|
;;;347        }
;;;348        
;;;349        switch(cmd)
00000a  b134              CBZ      r4,|L2.26|
00000c  2c01              CMP      r4,#1
00000e  d007              BEQ      |L2.32|
000010  2c03              CMP      r4,#3
000012  d008              BEQ      |L2.38|
000014  2c04              CMP      r4,#4
000016  d10c              BNE      |L2.50|
000018  e008              B        |L2.44|
                  |L2.26|
;;;350        {
;;;351            case 0x00:
;;;352            {
;;;353               UsartCalibrationPort();
00001a  f7fffffe          BL       UsartCalibrationPort
;;;354               break;
00001e  e009              B        |L2.52|
                  |L2.32|
;;;355            }
;;;356            case 0x01:
;;;357            {
;;;358                UsartSetPortNumber();
000020  f7fffffe          BL       UsartSetPortNumber
;;;359                break;
000024  e006              B        |L2.52|
                  |L2.38|
;;;360            }
;;;361            case 0x03:
;;;362            {
;;;363                UsartControlPortOnOff();
000026  f7fffffe          BL       UsartControlPortOnOff
;;;364                break;
00002a  e003              B        |L2.52|
                  |L2.44|
;;;365            }
;;;366            case 0x04:
;;;367            {
;;;368                UsartControlPortLed();
00002c  f7fffffe          BL       UsartControlPortLed
;;;369                break;
000030  e000              B        |L2.52|
                  |L2.50|
;;;370            }
;;;371            default:
;;;372            {
;;;373                break;
000032  bf00              NOP      
                  |L2.52|
000034  bf00              NOP                            ;354
;;;374            }
;;;375        }
;;;376    }
000036  bd10              POP      {r4,pc}
;;;377    
                          ENDP


                          AREA ||i.SendAckToSlave||, CODE, READONLY, ALIGN=2

                  SendAckToSlave PROC
;;;550    *******************************************************************************/
;;;551    bool SendAckToSlave(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;552    {     
;;;553        char AckData[8] = {0x0f,0x04,0x05,0x00,0x00,0x0A,0xFF,0xFF}; 
000002  a106              ADR      r1,|L3.28|
000004  c903              LDM      r1,{r0,r1}
000006  e9cd0100          STRD     r0,r1,[sp,#0]
;;;554        hfuart_send(huart1,AckData,sizeof(AckData),NULL);
00000a  2300              MOVS     r3,#0
00000c  2208              MOVS     r2,#8
00000e  4669              MOV      r1,sp
000010  4804              LDR      r0,|L3.36|
000012  6800              LDR      r0,[r0,#0]  ; huart1
000014  f7fffffe          BL       hfuart_send
;;;555        return true;
000018  2001              MOVS     r0,#1
;;;556    }
00001a  bd1c              POP      {r2-r4,pc}
;;;557    
                          ENDP

                  |L3.28|
00001c  0f040500          DCB      15,4,5,0
000020  00                DCB      0
000021  0affff            DCB      "\n",255,255
                  |L3.36|
                          DCD      huart1

                          AREA ||i.UsartCalibrationPort||, CODE, READONLY, ALIGN=2

                  UsartCalibrationPort PROC
;;;268    extern uint8_t CalibrateData[8];
;;;269    bool UsartCalibrationPort(void)
000000  b57f              PUSH     {r0-r6,lr}
;;;270    { 
;;;271        uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;272        char OrderData[15] = {0x0f,0x0B,0xAA,0x00,0x00,0x00,0x01,0x86,0xA0,0x01,0xF4,0xDC,0xA2,0xFF,0xFF};  
000004  a316              ADR      r3,|L4.96|
000006  cb0f              LDM      r3,{r0-r3}
000008  e88d000f          STM      sp,{r0-r3}
;;;273        uint16_t DataSum = 0;
00000c  2500              MOVS     r5,#0
;;;274        
;;;275        for(i=0;i<8;i++)        //计算LED的数据
00000e  bf00              NOP      
000010  e00b              B        |L4.42|
                  |L4.18|
;;;276        {
;;;277             OrderData[4+i] = *(CalibrateData+i);
000012  4817              LDR      r0,|L4.112|
000014  5d01              LDRB     r1,[r0,r4]
000016  1d20              ADDS     r0,r4,#4
000018  f80d1000          STRB     r1,[sp,r0]
;;;278             DataSum += OrderData[2+i];
00001c  1ca0              ADDS     r0,r4,#2
00001e  f81d0000          LDRB     r0,[sp,r0]
000022  4428              ADD      r0,r0,r5
000024  b285              UXTH     r5,r0
000026  1c60              ADDS     r0,r4,#1              ;275
000028  b2c4              UXTB     r4,r0                 ;275
                  |L4.42|
00002a  2c08              CMP      r4,#8                 ;275
00002c  dbf1              BLT      |L4.18|
;;;279        }
;;;280        DataSum = DataSum + OrderData[10]+ OrderData[11];
00002e  f89d000a          LDRB     r0,[sp,#0xa]
000032  4428              ADD      r0,r0,r5
000034  f89d100b          LDRB     r1,[sp,#0xb]
000038  4408              ADD      r0,r0,r1
00003a  b285              UXTH     r5,r0
;;;281        OrderData[12] = (DataSum+1)&0xff;
00003c  1c68              ADDS     r0,r5,#1
00003e  b2c0              UXTB     r0,r0
000040  f88d000c          STRB     r0,[sp,#0xc]
;;;282        
;;;283        hfuart_send(huart1,OrderData,sizeof(OrderData),NULL);
000044  2300              MOVS     r3,#0
000046  220f              MOVS     r2,#0xf
000048  4669              MOV      r1,sp
00004a  480a              LDR      r0,|L4.116|
00004c  6800              LDR      r0,[r0,#0]  ; huart1
00004e  f7fffffe          BL       hfuart_send
;;;284        orderArray[0].OrderMark = 0;
000052  2000              MOVS     r0,#0
000054  4908              LDR      r1,|L4.120|
000056  7008              STRB     r0,[r1,#0]
;;;285        orderArray[0].ACK = 0;
000058  7048              STRB     r0,[r1,#1]
;;;286        return true;
00005a  2001              MOVS     r0,#1
;;;287    } 
00005c  b004              ADD      sp,sp,#0x10
00005e  bd70              POP      {r4-r6,pc}
;;;288    
                          ENDP

                  |L4.96|
000060  0f0baa00          DCB      15,"\v",170,0
000064  00                DCB      0
000065  00                DCB      0
000066  0186a001          DCB      1,134,160,1,244,220,162,255,255,0
00006a  f4dca2ff
00006e  ff00    
                  |L4.112|
                          DCD      CalibrateData
                  |L4.116|
                          DCD      huart1
                  |L4.120|
                          DCD      orderArray

                          AREA ||i.UsartControlPortLed||, CODE, READONLY, ALIGN=2

                  UsartControlPortLed PROC
;;;238    *******************************************************************************/ 
;;;239    bool UsartControlPortLed()
000000  b57f              PUSH     {r0-r6,lr}
;;;240    { 
;;;241        uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;242        char OrderData[13] = {0x0f,0x09,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff};    
000004  a317              ADR      r3,|L5.100|
000006  cb0f              LDM      r3,{r0-r3}
000008  e88d000f          STM      sp,{r0-r3}
;;;243        uint16_t DataSum = 0;
00000c  2500              MOVS     r5,#0
;;;244        
;;;245        for(i=0;i<6;i++)        //计算LED的数据
00000e  bf00              NOP      
000010  e00b              B        |L5.42|
                  |L5.18|
;;;246        {
;;;247             OrderData[4+i] = *(LedFlashControl+i);
000012  4818              LDR      r0,|L5.116|
000014  5d01              LDRB     r1,[r0,r4]
000016  1d20              ADDS     r0,r4,#4
000018  f80d1000          STRB     r1,[sp,r0]
;;;248             DataSum += OrderData[2+i];
00001c  1ca0              ADDS     r0,r4,#2
00001e  f81d0000          LDRB     r0,[sp,r0]
000022  4428              ADD      r0,r0,r5
000024  b285              UXTH     r5,r0
000026  1c60              ADDS     r0,r4,#1              ;245
000028  b2c4              UXTB     r4,r0                 ;245
                  |L5.42|
00002a  2c06              CMP      r4,#6                 ;245
00002c  dbf1              BLT      |L5.18|
;;;249        }
;;;250        DataSum = DataSum + OrderData[8]+ OrderData[9];
00002e  f89d0008          LDRB     r0,[sp,#8]
000032  4428              ADD      r0,r0,r5
000034  f89d1009          LDRB     r1,[sp,#9]
000038  4408              ADD      r0,r0,r1
00003a  b285              UXTH     r5,r0
;;;251        OrderData[10] = (DataSum+1)&0xff;
00003c  1c68              ADDS     r0,r5,#1
00003e  b2c0              UXTB     r0,r0
000040  f88d000a          STRB     r0,[sp,#0xa]
;;;252    
;;;253        hfuart_send(huart1,OrderData,sizeof(OrderData),NULL);
000044  2300              MOVS     r3,#0
000046  220d              MOVS     r2,#0xd
000048  4669              MOV      r1,sp
00004a  480b              LDR      r0,|L5.120|
00004c  6800              LDR      r0,[r0,#0]  ; huart1
00004e  f7fffffe          BL       hfuart_send
;;;254        orderArray[4].OrderMark = 0;
000052  2000              MOVS     r0,#0
000054  4909              LDR      r1,|L5.124|
000056  7308              STRB     r0,[r1,#0xc]
;;;255        orderArray[4].ACK = 0;
000058  2100              MOVS     r1,#0
00005a  4808              LDR      r0,|L5.124|
00005c  7341              STRB     r1,[r0,#0xd]
;;;256        
;;;257        return true;
00005e  2001              MOVS     r0,#1
;;;258    } 
000060  b004              ADD      sp,sp,#0x10
000062  bd70              POP      {r4-r6,pc}
;;;259    
                          ENDP

                  |L5.100|
000064  0f090400          DCB      15,"\t",4,0
000068  00                DCB      0
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  00                DCB      0
00006d  00                DCB      0
00006e  00                DCB      0
00006f  ffff00            DCB      255,255,0
000072  00                DCB      0
000073  00                DCB      0
                  |L5.116|
                          DCD      LedFlashControl
                  |L5.120|
                          DCD      huart1
                  |L5.124|
                          DCD      orderArray

                          AREA ||i.UsartControlPortOnOff||, CODE, READONLY, ALIGN=2

                  UsartControlPortOnOff PROC
;;;204    *******************************************************************************/ 
;;;205    bool UsartControlPortOnOff()
000000  b57c              PUSH     {r2-r6,lr}
;;;206    { 	
;;;207        uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;208        char OrderData[8] = {0x0f,0x04,0x03,0x00,SwOnOffData,0x00,0xff,0xff};    
000004  a113              ADR      r1,|L6.84|
000006  c903              LDM      r1,{r0,r1}
000008  e9cd0100          STRD     r0,r1,[sp,#0]
00000c  4813              LDR      r0,|L6.92|
00000e  7800              LDRB     r0,[r0,#0]  ; SwOnOffData
000010  f88d0004          STRB     r0,[sp,#4]
;;;209        uint16_t DataSum = 0;
000014  2500              MOVS     r5,#0
;;;210    //	char test[100];
;;;211        
;;;212        for(i=0;i<3;i++)
000016  bf00              NOP      
000018  e006              B        |L6.40|
                  |L6.26|
;;;213        {       
;;;214             DataSum += OrderData[2+i];
00001a  1ca0              ADDS     r0,r4,#2
00001c  f81d0000          LDRB     r0,[sp,r0]
000020  4428              ADD      r0,r0,r5
000022  b285              UXTH     r5,r0
000024  1c60              ADDS     r0,r4,#1              ;212
000026  b2c4              UXTB     r4,r0                 ;212
                  |L6.40|
000028  2c03              CMP      r4,#3                 ;212
00002a  dbf6              BLT      |L6.26|
;;;215        }
;;;216    		
;;;217        OrderData[5] = (DataSum+1)&0xff;
00002c  1c68              ADDS     r0,r5,#1
00002e  b2c0              UXTB     r0,r0
000030  f88d0005          STRB     r0,[sp,#5]
;;;218        hfuart_send(huart1,OrderData,sizeof(OrderData),NULL);
000034  2300              MOVS     r3,#0
000036  2208              MOVS     r2,#8
000038  4669              MOV      r1,sp
00003a  4809              LDR      r0,|L6.96|
00003c  6800              LDR      r0,[r0,#0]  ; huart1
00003e  f7fffffe          BL       hfuart_send
;;;219        orderArray[3].OrderMark = 0;
000042  2000              MOVS     r0,#0
000044  4907              LDR      r1,|L6.100|
000046  7248              STRB     r0,[r1,#9]
;;;220        orderArray[3].ACK = 0;
000048  2100              MOVS     r1,#0
00004a  4806              LDR      r0,|L6.100|
00004c  7281              STRB     r1,[r0,#0xa]
;;;221    
;;;222    #if 0
;;;223    	memset(test,0,sizeof(test));
;;;224    	sprintf(test,"\nSwOnOffData=%d\n",SwOnOffData);
;;;225    	UdpDebugPrint(test,sizeof(test));
;;;226    #endif
;;;227    	
;;;228        return true;
00004e  2001              MOVS     r0,#1
;;;229    } 
000050  bd7c              POP      {r2-r6,pc}
;;;230    
                          ENDP

000052  0000              DCW      0x0000
                  |L6.84|
000054  0f040300          DCB      15,4,3,0
000058  00                DCB      0
000059  00                DCB      0
00005a  ffff              DCB      255,255
                  |L6.92|
                          DCD      SwOnOffData
                  |L6.96|
                          DCD      huart1
                  |L6.100|
                          DCD      orderArray

                          AREA ||i.UsartReadPortData||, CODE, READONLY, ALIGN=2

                  UsartReadPortData PROC
;;;168    *******************************************************************************/ 
;;;169    bool UsartReadPortData(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;170    { 
;;;171        char OrderData[7] = {0x0f,0x03,0x02,0x00,0x03,0xff,0xff}; 
000002  a106              ADR      r1,|L7.28|
000004  c903              LDM      r1,{r0,r1}
000006  e9cd0100          STRD     r0,r1,[sp,#0]
;;;172          
;;;173           
;;;174        hfuart_send(huart1,OrderData,sizeof(OrderData),NULL);
00000a  2300              MOVS     r3,#0
00000c  2207              MOVS     r2,#7
00000e  4669              MOV      r1,sp
000010  4804              LDR      r0,|L7.36|
000012  6800              LDR      r0,[r0,#0]  ; huart1
000014  f7fffffe          BL       hfuart_send
;;;175        
;;;176        return true;
000018  2001              MOVS     r0,#1
;;;177    } 
00001a  bd1c              POP      {r2-r4,pc}
;;;178    
                          ENDP

                  |L7.28|
00001c  0f030200          DCB      15,3,2,0
000020  03ffff00          DCB      3,255,255,0
                  |L7.36|
                          DCD      huart1

                          AREA ||i.UsartReadPortstatus||, CODE, READONLY, ALIGN=2

                  UsartReadPortstatus PROC
;;;185    *******************************************************************************/ 
;;;186    bool UsartReadPortstatus(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;187    { 
;;;188        //char OrderData[7] = {0x0f,0x03,0x02,0x00,0x03,0xff,0xff}; 
;;;189        char OrderData[7] = {0x0f,0x03,0x05,0x00,0x06,0xff,0xff};
000002  a106              ADR      r1,|L8.28|
000004  c903              LDM      r1,{r0,r1}
000006  e9cd0100          STRD     r0,r1,[sp,#0]
;;;190           
;;;191        hfuart_send(huart1,OrderData,sizeof(OrderData),NULL);
00000a  2300              MOVS     r3,#0
00000c  2207              MOVS     r2,#7
00000e  4669              MOV      r1,sp
000010  4804              LDR      r0,|L8.36|
000012  6800              LDR      r0,[r0,#0]  ; huart1
000014  f7fffffe          BL       hfuart_send
;;;192        
;;;193        return true;
000018  2001              MOVS     r0,#1
;;;194    } 
00001a  bd1c              POP      {r2-r4,pc}
;;;195    
                          ENDP

                  |L8.28|
00001c  0f030500          DCB      15,3,5,0
000020  06ffff00          DCB      6,255,255,0
                  |L8.36|
                          DCD      huart1

                          AREA ||i.UsartSetPortNumber||, CODE, READONLY, ALIGN=2

                  UsartSetPortNumber PROC
;;;139    *******************************************************************************/ 
;;;140    bool UsartSetPortNumber()
000000  b53e              PUSH     {r1-r5,lr}
;;;141    { 
;;;142        uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;143        char OrderData[10] = {0x0f,0x06,0x01,0x00,portNum,0,0,0,0xff,0xff};    //命令码
000004  a213              ADR      r2,|L9.84|
000006  ca07              LDM      r2,{r0-r2}
000008  e88d0007          STM      sp,{r0-r2}
00000c  4814              LDR      r0,|L9.96|
00000e  7800              LDRB     r0,[r0,#0]  ; portNum
000010  f88d0004          STRB     r0,[sp,#4]
;;;144        uint16_t DataSum = 0;
000014  2500              MOVS     r5,#0
;;;145        
;;;146        for(i=0;i<5;i++)
000016  bf00              NOP      
000018  e006              B        |L9.40|
                  |L9.26|
;;;147        {
;;;148             
;;;149             DataSum += OrderData[2+i];
00001a  1ca0              ADDS     r0,r4,#2
00001c  f81d0000          LDRB     r0,[sp,r0]
000020  4428              ADD      r0,r0,r5
000022  b285              UXTH     r5,r0
000024  1c60              ADDS     r0,r4,#1              ;146
000026  b2c4              UXTB     r4,r0                 ;146
                  |L9.40|
000028  2c05              CMP      r4,#5                 ;146
00002a  dbf6              BLT      |L9.26|
;;;150        }
;;;151    		
;;;152        OrderData[7] = (DataSum+1)&0xff;
00002c  1c68              ADDS     r0,r5,#1
00002e  b2c0              UXTB     r0,r0
000030  f88d0007          STRB     r0,[sp,#7]
;;;153        
;;;154        hfuart_send(huart1,OrderData,sizeof(OrderData),NULL);
000034  2300              MOVS     r3,#0
000036  220a              MOVS     r2,#0xa
000038  4669              MOV      r1,sp
00003a  480a              LDR      r0,|L9.100|
00003c  6800              LDR      r0,[r0,#0]  ; huart1
00003e  f7fffffe          BL       hfuart_send
;;;155        orderArray[1].OrderMark = 0;
000042  2000              MOVS     r0,#0
000044  4908              LDR      r1,|L9.104|
000046  70c8              STRB     r0,[r1,#3]
;;;156        orderArray[1].ACK = 0;
000048  2100              MOVS     r1,#0
00004a  4807              LDR      r0,|L9.104|
00004c  7101              STRB     r1,[r0,#4]
;;;157        
;;;158        return true;
00004e  2001              MOVS     r0,#1
;;;159    } 
000050  bd3e              POP      {r1-r5,pc}
;;;160    
                          ENDP

000052  0000              DCW      0x0000
                  |L9.84|
000054  0f060100          DCB      15,6,1,0
000058  00                DCB      0
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
00005c  ffff00            DCB      255,255,0
00005f  00                DCB      0
                  |L9.96|
                          DCD      portNum
                  |L9.100|
                          DCD      huart1
                  |L9.104|
                          DCD      orderArray

                          AREA ||i.dealReplyACK||, CODE, READONLY, ALIGN=2

                  dealReplyACK PROC
;;;385    *******************************************************************************/
;;;386    void dealReplyACK(UsartOrderType *slaveRecvData)
000000  7901              LDRB     r1,[r0,#4]
;;;387    {
;;;388    
;;;389        if(0x00 == slaveRecvData->data[0])
000002  b989              CBNZ     r1,|L10.40|
;;;390        {
;;;391            orderArray[slaveRecvData->cmd].ACK = 1;        //the order excute ok
000004  2101              MOVS     r1,#1
000006  7882              LDRB     r2,[r0,#2]
000008  eb020242          ADD      r2,r2,r2,LSL #1
00000c  4b0a              LDR      r3,|L10.56|
00000e  441a              ADD      r2,r2,r3
000010  7051              STRB     r1,[r2,#1]
;;;392            orderArray[slaveRecvData->cmd].OrderMark = 0;
000012  2100              MOVS     r1,#0
000014  7882              LDRB     r2,[r0,#2]
000016  eb020242          ADD      r2,r2,r2,LSL #1
00001a  5499              STRB     r1,[r3,r2]
;;;393            orderArray[slaveRecvData->cmd].sendCount = 0;
00001c  7882              LDRB     r2,[r0,#2]
00001e  eb020242          ADD      r2,r2,r2,LSL #1
000022  441a              ADD      r2,r2,r3
000024  7091              STRB     r1,[r2,#2]
000026  e006              B        |L10.54|
                  |L10.40|
;;;394            //u_printf("order excute succeed!\n");
;;;395        }
;;;396        else
;;;397        {
;;;398            orderArray[slaveRecvData->cmd].ACK = 0;        //the order excute failed,resend the order
000028  2100              MOVS     r1,#0
00002a  7882              LDRB     r2,[r0,#2]
00002c  eb020242          ADD      r2,r2,r2,LSL #1
000030  4b01              LDR      r3,|L10.56|
000032  441a              ADD      r2,r2,r3
000034  7051              STRB     r1,[r2,#1]
                  |L10.54|
;;;399            //u_printf("order excute failed! order[%d].sendCount = %d\n",slaveRecvData->cmd,orderArray[slaveRecvData->cmd].sendCount); 
;;;400        }
;;;401    }
000036  4770              BX       lr
;;;402    
                          ENDP

                  |L10.56|
                          DCD      orderArray

                          AREA ||i.dealSlaveData||, CODE, READONLY, ALIGN=1

                  dealSlaveData PROC
;;;296    *******************************************************************************/
;;;297    void dealSlaveData(UsartOrderType *slaveRecvData)
000000  b510              PUSH     {r4,lr}
;;;298    {
000002  4604              MOV      r4,r0
;;;299        if(0xAA == (int)slaveRecvData->cmd)
000004  78a0              LDRB     r0,[r4,#2]
000006  28aa              CMP      r0,#0xaa
000008  d101              BNE      |L11.14|
;;;300        {
;;;301            slaveRecvData->cmd = 0x00;
00000a  2000              MOVS     r0,#0
00000c  70a0              STRB     r0,[r4,#2]
                  |L11.14|
;;;302        }
;;;303        
;;;304        switch (slaveRecvData->cmd)
00000e  78a0              LDRB     r0,[r4,#2]
000010  2806              CMP      r0,#6
000012  d212              BCS      |L11.58|
000014  e8dff000          TBB      [pc,r0]
000018  03040705          DCB      0x03,0x04,0x07,0x05
00001c  060b              DCB      0x06,0x0b
;;;305        {
;;;306            case 0x00:
;;;307            case 0x01:
00001e  bf00              NOP      
;;;308            case 0x03:
000020  bf00              NOP      
;;;309            case 0x04:
000022  bf00              NOP      
;;;310            {
;;;311                //dealReplyACK(slaveRecvData);  
;;;312                break;
000024  e00a              B        |L11.60|
;;;313            }
;;;314    
;;;315            case 0x02:
;;;316            {
;;;317            	//UdpDebugPrint("Now we get the switch info!!!",strlen("Now we get the switch info!!!"));
;;;318                getPortData(slaveRecvData->data);             //提取出每个port的电压，电流，功率
000026  1d20              ADDS     r0,r4,#4
000028  f7fffffe          BL       getPortData
;;;319                break;
00002c  e006              B        |L11.60|
;;;320            }
;;;321            case 0x05:
;;;322            {
;;;323                getPortState(slaveRecvData->data);             //提取出每个port的开关状态
00002e  1d20              ADDS     r0,r4,#4
000030  f7fffffe          BL       getPortState
;;;324                SendAckToSlave();                              //给下位机发送应答码
000034  f7fffffe          BL       SendAckToSlave
;;;325                break;
000038  e000              B        |L11.60|
                  |L11.58|
;;;326            }
;;;327            default:
;;;328            {
;;;329                break;
00003a  bf00              NOP      
                  |L11.60|
00003c  bf00              NOP                            ;312
;;;330            }
;;;331        }
;;;332    }
00003e  bd10              POP      {r4,pc}
;;;333    
                          ENDP


                          AREA ||i.getPortData||, CODE, READONLY, ALIGN=2

                  getPortData PROC
;;;471    *******************************************************************************/
;;;472    void getPortData(char *data)
000000  b510              PUSH     {r4,lr}
;;;473    {
000002  4601              MOV      r1,r0
;;;474        uint8_t i = 0;
000004  2000              MOVS     r0,#0
;;;475    
;;;476    	//char testBuffer[100];
;;;477    
;;;478        
;;;479        for(i=0;i<portNum;i++)
000006  bf00              NOP      
000008  e066              B        |L12.216|
                  |L12.10|
;;;480        {   
;;;481            PowerRecordObj[i].record_ValidVolt = data[0];
00000a  780a              LDRB     r2,[r1,#0]
00000c  ebc003c0          RSB      r3,r0,r0,LSL #3
000010  4c36              LDR      r4,|L12.236|
000012  eb040383          ADD      r3,r4,r3,LSL #2
000016  60da              STR      r2,[r3,#0xc]
;;;482            PowerRecordObj[i].record_ValidFreq = data[1];
000018  784a              LDRB     r2,[r1,#1]
00001a  ebc003c0          RSB      r3,r0,r0,LSL #3
00001e  f8442023          STR      r2,[r4,r3,LSL #2]
;;;483            PowerRecordObj[i].record_ValidPower = (data[2+6*i]<<24)+(data[3+6*i]<<16)+(data[4+6*i]<<8)+(data[5+6*i]<<0);
000022  eb000240          ADD      r2,r0,r0,LSL #1
000026  0052              LSLS     r2,r2,#1
000028  1c92              ADDS     r2,r2,#2
00002a  5c8a              LDRB     r2,[r1,r2]
00002c  0613              LSLS     r3,r2,#24
00002e  eb000240          ADD      r2,r0,r0,LSL #1
000032  0052              LSLS     r2,r2,#1
000034  1cd2              ADDS     r2,r2,#3
000036  5c8a              LDRB     r2,[r1,r2]
000038  eb034302          ADD      r3,r3,r2,LSL #16
00003c  eb000240          ADD      r2,r0,r0,LSL #1
000040  0052              LSLS     r2,r2,#1
000042  1d12              ADDS     r2,r2,#4
000044  5c8a              LDRB     r2,[r1,r2]
000046  eb032302          ADD      r3,r3,r2,LSL #8
00004a  eb000240          ADD      r2,r0,r0,LSL #1
00004e  0052              LSLS     r2,r2,#1
000050  1d52              ADDS     r2,r2,#5
000052  5c8a              LDRB     r2,[r1,r2]
000054  441a              ADD      r2,r2,r3
000056  ebc003c0          RSB      r3,r0,r0,LSL #3
00005a  eb040383          ADD      r3,r4,r3,LSL #2
00005e  615a              STR      r2,[r3,#0x14]
;;;484    	
;;;485    		if((500>PowerRecordObj[i].record_ValidPower) || (SwInformation.PortInfor[i].OnOffStatus==0)) 
000060  ebc002c0          RSB      r2,r0,r0,LSL #3
000064  4623              MOV      r3,r4
000066  eb030282          ADD      r2,r3,r2,LSL #2
00006a  6952              LDR      r2,[r2,#0x14]
00006c  f5b27ffa          CMP      r2,#0x1f4
000070  db06              BLT      |L12.128|
000072  eb000380          ADD      r3,r0,r0,LSL #2
000076  4a1e              LDR      r2,|L12.240|
000078  eb020283          ADD      r2,r2,r3,LSL #2
00007c  7c52              LDRB     r2,[r2,#0x11]
00007e  b932              CBNZ     r2,|L12.142|
                  |L12.128|
;;;486    		{
;;;487    		    PowerRecordObj[i].record_ValidPower = 0;
000080  2200              MOVS     r2,#0
000082  ebc003c0          RSB      r3,r0,r0,LSL #3
000086  4c19              LDR      r4,|L12.236|
000088  eb040383          ADD      r3,r4,r3,LSL #2
00008c  615a              STR      r2,[r3,#0x14]
                  |L12.142|
;;;488    		} 
;;;489    
;;;490            PowerRecordObj[i].record_ValidCurrent = (data[6+6*i]<<8)+(data[7+6*i]<<0);
00008e  eb000240          ADD      r2,r0,r0,LSL #1
000092  0052              LSLS     r2,r2,#1
000094  1dd2              ADDS     r2,r2,#7
000096  5c8b              LDRB     r3,[r1,r2]
000098  eb000240          ADD      r2,r0,r0,LSL #1
00009c  0052              LSLS     r2,r2,#1
00009e  1d92              ADDS     r2,r2,#6
0000a0  5c8a              LDRB     r2,[r1,r2]
0000a2  eb032202          ADD      r2,r3,r2,LSL #8
0000a6  ebc003c0          RSB      r3,r0,r0,LSL #3
0000aa  4c10              LDR      r4,|L12.236|
0000ac  eb040383          ADD      r3,r4,r3,LSL #2
0000b0  605a              STR      r2,[r3,#4]
;;;491    
;;;492            TempPowerStaticsSum[i] += ((PowerRecordObj[i].record_ValidPower+5)/10);        //每2s读取一次数据
0000b2  ebc002c0          RSB      r2,r0,r0,LSL #3
0000b6  4623              MOV      r3,r4
0000b8  eb030282          ADD      r2,r3,r2,LSL #2
0000bc  6952              LDR      r2,[r2,#0x14]
0000be  1d52              ADDS     r2,r2,#5
0000c0  230a              MOVS     r3,#0xa
0000c2  fb92f2f3          SDIV     r2,r2,r3
0000c6  4b0b              LDR      r3,|L12.244|
0000c8  f8533020          LDR      r3,[r3,r0,LSL #2]
0000cc  441a              ADD      r2,r2,r3
0000ce  4b09              LDR      r3,|L12.244|
0000d0  f8432020          STR      r2,[r3,r0,LSL #2]
0000d4  1c42              ADDS     r2,r0,#1              ;479
0000d6  b2d0              UXTB     r0,r2                 ;479
                  |L12.216|
0000d8  4a07              LDR      r2,|L12.248|
0000da  7812              LDRB     r2,[r2,#0]            ;479  ; portNum
0000dc  4290              CMP      r0,r2                 ;479
0000de  db94              BLT      |L12.10|
;;;493            
;;;494            //MinutePowerConsum[i] += PowerRecordObj[i].record_ValidPower*2;        //每2s读取一次数据
;;;495            
;;;496     //       UdpDebugPrint("we've got the power!\n",sizeof("we've got the power!\n")-1);   
;;;497    #if 0
;;;498    		if(readPowerCount%5 == 0)
;;;499    		{
;;;500    			memset(testBuffer,0,sizeof(testBuffer));
;;;501    	 		sprintf(testBuffer,"port[%d]:power=%d\t	sumPower=%d\t readPowerCount=%d\n",i,
;;;502    	 				PowerRecordObj[i].record_ValidPower,TempPowerStaticsSum[i],readPowerCount);
;;;503    			UdpDebugPrint(testBuffer,strlen(testBuffer));
;;;504    		}
;;;505    #endif
;;;506        }
;;;507    	readPowerCount++; 
0000e0  4a06              LDR      r2,|L12.252|
0000e2  6812              LDR      r2,[r2,#0]  ; readPowerCount
0000e4  1c52              ADDS     r2,r2,#1
0000e6  4b05              LDR      r3,|L12.252|
0000e8  601a              STR      r2,[r3,#0]  ; readPowerCount
;;;508    	
;;;509    }
0000ea  bd10              POP      {r4,pc}
;;;510    
                          ENDP

                  |L12.236|
                          DCD      PowerRecordObj
                  |L12.240|
                          DCD      SwInformation+0x8
                  |L12.244|
                          DCD      TempPowerStaticsSum
                  |L12.248|
                          DCD      portNum
                  |L12.252|
                          DCD      readPowerCount

                          AREA ||i.getPortNumber||, CODE, READONLY, ALIGN=2

                  getPortNumber PROC
;;;459    *******************************************************************************/
;;;460    char getPortNumber(char *data)
000000  4601              MOV      r1,r0
;;;461    {
;;;462        return (portNum=data[0]);
000002  7808              LDRB     r0,[r1,#0]
000004  4a01              LDR      r2,|L13.12|
000006  7010              STRB     r0,[r2,#0]
;;;463    }
000008  4770              BX       lr
;;;464    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      portNum

                          AREA ||i.getPortState||, CODE, READONLY, ALIGN=2

                  getPortState PROC
;;;516    *******************************************************************************/
;;;517    void getPortState(char *Data)
000000  b530              PUSH     {r4,r5,lr}
;;;518    {   
000002  4601              MOV      r1,r0
;;;519         uint8_t portID = 0;
000004  2000              MOVS     r0,#0
;;;520         char OnOffData = 0;
000006  2200              MOVS     r2,#0
;;;521         
;;;522         OnOffData=*Data; 
000008  780a              LDRB     r2,[r1,#0]
;;;523    	 
;;;524         for(portID = 0;portID <PORT_NUM;portID++)
00000a  bf00              NOP      
00000c  e02f              B        |L14.110|
                  |L14.14|
;;;525         { 
;;;526    		if(SwInformation.PortInfor[portID].OnOffStatus)
00000e  eb000480          ADD      r4,r0,r0,LSL #2
000012  4b1c              LDR      r3,|L14.132|
000014  eb030384          ADD      r3,r3,r4,LSL #2
000018  7c5b              LDRB     r3,[r3,#0x11]
00001a  b163              CBZ      r3,|L14.54|
;;;527            {
;;;528                SwOnOffData |= SwInformation.PortInfor[portID].OnOffStatus<<portID;
00001c  eb000480          ADD      r4,r0,r0,LSL #2
000020  4b18              LDR      r3,|L14.132|
000022  eb030384          ADD      r3,r3,r4,LSL #2
000026  7c5b              LDRB     r3,[r3,#0x11]
000028  4083              LSLS     r3,r3,r0
00002a  4c17              LDR      r4,|L14.136|
00002c  7824              LDRB     r4,[r4,#0]  ; SwOnOffData
00002e  4323              ORRS     r3,r3,r4
000030  4c15              LDR      r4,|L14.136|
000032  7023              STRB     r3,[r4,#0]
000034  e00f              B        |L14.86|
                  |L14.54|
;;;529            }
;;;530            else
;;;531            {
;;;532                SwOnOffData &= ~((!SwInformation.PortInfor[portID].OnOffStatus)<<portID);
000036  eb000480          ADD      r4,r0,r0,LSL #2
00003a  4b12              LDR      r3,|L14.132|
00003c  eb030384          ADD      r3,r3,r4,LSL #2
000040  7c5b              LDRB     r3,[r3,#0x11]
000042  b90b              CBNZ     r3,|L14.72|
000044  2301              MOVS     r3,#1
000046  e000              B        |L14.74|
                  |L14.72|
000048  2300              MOVS     r3,#0
                  |L14.74|
00004a  4083              LSLS     r3,r3,r0
00004c  4c0e              LDR      r4,|L14.136|
00004e  7824              LDRB     r4,[r4,#0]  ; SwOnOffData
000050  439c              BICS     r4,r4,r3
000052  4b0d              LDR      r3,|L14.136|
000054  701c              STRB     r4,[r3,#0]
                  |L14.86|
;;;533            }
;;;534    		
;;;535            SwInformation.PortInfor[portID].OnOffStatus = ((OnOffData&(1<<portID))>>portID); 
000056  2301              MOVS     r3,#1
000058  4083              LSLS     r3,r3,r0
00005a  4013              ANDS     r3,r3,r2
00005c  4103              ASRS     r3,r3,r0
00005e  eb000580          ADD      r5,r0,r0,LSL #2
000062  4c08              LDR      r4,|L14.132|
000064  eb040485          ADD      r4,r4,r5,LSL #2
000068  7463              STRB     r3,[r4,#0x11]
00006a  1c43              ADDS     r3,r0,#1              ;524
00006c  b2d8              UXTB     r0,r3                 ;524
                  |L14.110|
00006e  2806              CMP      r0,#6                 ;524
000070  dbcd              BLT      |L14.14|
;;;536            //u_printf("port[%d] status = %d\n",portID,SwInformation.PortInfor[portID].OnOffStatus);
;;;537         }
;;;538    
;;;539    	 if(OnOffData != SwOnOffData)
000072  4b05              LDR      r3,|L14.136|
000074  781b              LDRB     r3,[r3,#0]  ; SwOnOffData
000076  429a              CMP      r2,r3
000078  d003              BEQ      |L14.130|
;;;540    	 {
;;;541    	 	SwInformation.portChangeReason = PORT_CHANGE_BY_KEY;
00007a  2302              MOVS     r3,#2
00007c  4c01              LDR      r4,|L14.132|
00007e  3c08              SUBS     r4,r4,#8
000080  70e3              STRB     r3,[r4,#3]
                  |L14.130|
;;;542    	 }
;;;543    }
000082  bd30              POP      {r4,r5,pc}
;;;544    
                          ENDP

                  |L14.132|
                          DCD      SwInformation+0x8
                  |L14.136|
                          DCD      SwOnOffData

                          AREA ||i.uart_process_callback||, CODE, READONLY, ALIGN=1

                  uart_process_callback PROC
;;;45     *******************************************************************************/
;;;46     extern int USER_FUNC uart_process_callback(uint32_t event, char *pRecvData, uint32_t len,uint32_t buf_len)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;47     {
000004  b08d              SUB      sp,sp,#0x34
000006  4683              MOV      r11,r0
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
;;;48     	uint8_t i = 0;
00000c  2500              MOVS     r5,#0
;;;49         char *dataBuffer = pRecvData;
00000e  4634              MOV      r4,r6
;;;50         uint8_t slaveDataLength = 0;
000010  46a9              MOV      r9,r5
;;;51         uint8_t checkSum = 0;
000012  46aa              MOV      r10,r5
;;;52         uint16_t dataSum = 0;
000014  46a8              MOV      r8,r5
;;;53     	UsartOrderType slaveData;
;;;54     
;;;55     	//char testBuf[100] = {0};
;;;56     
;;;57     //	UdpDebugPrint(pRecvData, len);    
;;;58     
;;;59         if(0x0F == dataBuffer[0])
000016  7820              LDRB     r0,[r4,#0]
000018  280f              CMP      r0,#0xf
00001a  d138              BNE      |L15.142|
;;;60         {
;;;61             slaveData.length = dataBuffer[1];
00001c  7860              LDRB     r0,[r4,#1]
00001e  f88d0001          STRB     r0,[sp,#1]
;;;62             slaveData.cmd = dataBuffer[2];
000022  78a0              LDRB     r0,[r4,#2]
000024  f88d0002          STRB     r0,[sp,#2]
;;;63             slaveData.portID= dataBuffer[3];
000028  78e0              LDRB     r0,[r4,#3]
00002a  f88d0003          STRB     r0,[sp,#3]
;;;64             slaveDataLength = slaveData.length-3;
00002e  f89d0001          LDRB     r0,[sp,#1]
000032  1ec0              SUBS     r0,r0,#3
000034  f00009ff          AND      r9,r0,#0xff
;;;65             
;;;66             for(i=0;i<slaveDataLength;i++)
000038  bf00              NOP      
00003a  e00a              B        |L15.82|
                  |L15.60|
;;;67             {
;;;68                 slaveData.data[i] = *(dataBuffer+4+i);
00003c  1d20              ADDS     r0,r4,#4
00003e  5d41              LDRB     r1,[r0,r5]
000040  a801              ADD      r0,sp,#4
000042  5541              STRB     r1,[r0,r5]
;;;69                  dataSum += *(dataBuffer+4+i);        //filter the  start/length/CMD/ID
000044  1d20              ADDS     r0,r4,#4
000046  5d40              LDRB     r0,[r0,r5]
000048  4440              ADD      r0,r0,r8
00004a  fa1ff880          UXTH     r8,r0
00004e  1c68              ADDS     r0,r5,#1              ;66
000050  b2c5              UXTB     r5,r0                 ;66
                  |L15.82|
000052  454d              CMP      r5,r9                 ;66
000054  dbf2              BLT      |L15.60|
;;;70             }
;;;71             slaveData.checkSum = *(dataBuffer+4+i);
000056  1d20              ADDS     r0,r4,#4
000058  5d40              LDRB     r0,[r0,r5]
00005a  f88d0031          STRB     r0,[sp,#0x31]
;;;72             slaveData.lEnd = *(dataBuffer+5+i);
00005e  1d60              ADDS     r0,r4,#5
000060  5d40              LDRB     r0,[r0,r5]
000062  f88d0032          STRB     r0,[sp,#0x32]
;;;73             slaveData.hEnd = *(dataBuffer+6+i);
000066  1da0              ADDS     r0,r4,#6
000068  5d40              LDRB     r0,[r0,r5]
00006a  f88d0033          STRB     r0,[sp,#0x33]
;;;74     
;;;75             checkSum = (slaveData.cmd+slaveData.portID+dataSum+1)&0xff;
00006e  f89d0002          LDRB     r0,[sp,#2]
000072  f89d1003          LDRB     r1,[sp,#3]
000076  4408              ADD      r0,r0,r1
000078  4440              ADD      r0,r0,r8
00007a  1c40              ADDS     r0,r0,#1
00007c  f0000aff          AND      r10,r0,#0xff
;;;76             //sprintf(testBuf,"Length=%0X,cmd=%0X,portID=%0x,data_length=%d\n",slaveData.length,slaveData.cmd,slaveData.portID,slaveDataLength);
;;;77             //UdpDebugPrint(testBuf,strlen(testBuf));
;;;78            // u_printf("The original checkSum = %0X,checkSum = %0X\n",dataBuffer[len-3],checkSum);
;;;79             
;;;80     
;;;81             if(checkSum == dataBuffer[len-3])
000080  1ef8              SUBS     r0,r7,#3
000082  5c20              LDRB     r0,[r4,r0]
000084  4550              CMP      r0,r10
000086  d102              BNE      |L15.142|
;;;82             {
;;;83                 dealSlaveData(&slaveData);
000088  4668              MOV      r0,sp
00008a  f7fffffe          BL       dealSlaveData
                  |L15.142|
;;;84                 //getPortData(slaveData.data);
;;;85                 //getPortState(slaveData.data);
;;;86                 
;;;87             }
;;;88             else
;;;89             {
;;;90                 //u_printf("checksum error!\n");
;;;91             }
;;;92         }
;;;93         else
;;;94         {
;;;95             //u_printf("start code error!\n");
;;;96         }
;;;97         
;;;98         return len;
00008e  4638              MOV      r0,r7
;;;99     }
000090  b00d              ADD      sp,sp,#0x34
000092  e8bd8ff0          POP      {r4-r11,pc}
;;;100    
                          ENDP


                          AREA ||i.uart_process_init||, CODE, READONLY, ALIGN=2

                  uart_process_init PROC
;;;108    *******************************************************************************/
;;;109    void uart_process_init(void)
000000  b500              PUSH     {lr}
;;;110    {
000002  b08d              SUB      sp,sp,#0x34
;;;111        char     AtAckMsg[BOOT_INFO_DATA_BUF_LENGTH+1]={0};
000004  2134              MOVS     r1,#0x34
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;112        
;;;113    	//huart1 = hfuart_open(0);
;;;114    	
;;;115        hfat_send_cmd("AT+UART=115200,8,1,NONE,NFC\r\n", sizeof("AT+UART=115200,8,1,NONE,NFC\r\n")-1, AtAckMsg, 19);
00000c  2313              MOVS     r3,#0x13
00000e  466a              MOV      r2,sp
000010  211d              MOVS     r1,#0x1d
000012  a005              ADR      r0,|L16.40|
000014  f7fffffe          BL       hfat_send_cmd
;;;116    
;;;117        huart1 = hfuart_open(0);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       hfuart_open
00001e  490a              LDR      r1,|L16.72|
000020  6008              STR      r0,[r1,#0]  ; huart1
;;;118    	
;;;119    	#if  0 
;;;120    	if(NULL == huart1)
;;;121    	{
;;;122    		u_printf("uart_process init err...\r\n");
;;;123    	}
;;;124    	else
;;;125    	{
;;;126    		//u_printf("uart_process init OK...\r\n");
;;;127    	}
;;;128    	
;;;129    	#endif 
;;;130    }
000022  b00d              ADD      sp,sp,#0x34
000024  bd00              POP      {pc}
;;;131    
                          ENDP

000026  0000              DCW      0x0000
                  |L16.40|
000028  41542b55          DCB      "AT+UART=115200,8,1,NONE,NFC\r\n",0
00002c  4152543d
000030  31313532
000034  30302c38
000038  2c312c4e
00003c  4f4e452c
000040  4e46430d
000044  0a00    
000046  00                DCB      0
000047  00                DCB      0
                  |L16.72|
                          DCD      huart1

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  orderArray
                          %        21

                          AREA ||.data||, DATA, ALIGN=2

                  huart1
                          DCD      0x00000000
