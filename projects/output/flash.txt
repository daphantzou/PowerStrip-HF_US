; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\flash.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=494 -I../sdk/1.50/include/ -I../inc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -D__KEIL_MDK__ -D__LPB100__ --enum_is_int --omf_browse=.\output\flash.crf ..\src\flash.c]
                          THUMB

                          AREA ||i.CheckDevMode||, CODE, READONLY, ALIGN=2

                  CheckDevMode PROC
;;;169    extern DevInfoType DevInfoObj;
;;;170    void CheckDevMode(void) 
000000  b510              PUSH     {r4,lr}
;;;171    {
000002  b08e              SUB      sp,sp,#0x38
;;;172    	char	 AtAckMsg[BOOT_INFO_DATA_BUF_LENGTH+1]={0};
000004  2134              MOVS     r1,#0x34
000006  a801              ADD      r0,sp,#4
000008  f7fffffe          BL       __aeabi_memclr4
;;;173    	char	*pS8Tmp;
;;;174    
;;;175    	hfat_send_cmd("AT+WMODE\r\n", sizeof("AT+WMODE\r\n")-1, AtAckMsg, 19);
00000c  2313              MOVS     r3,#0x13
00000e  aa01              ADD      r2,sp,#4
000010  210a              MOVS     r1,#0xa
000012  a021              ADR      r0,|L1.152|
000014  f7fffffe          BL       hfat_send_cmd
;;;176    	pS8Tmp = strstr(AtAckMsg, "AP");				//没有找到"AP"
000018  a122              ADR      r1,|L1.164|
00001a  a801              ADD      r0,sp,#4
00001c  f7fffffe          BL       strstr
000020  4604              MOV      r4,r0
;;;177    
;;;178    	
;;;179    	if(NULL == pS8Tmp)
000022  bbbc              CBNZ     r4,|L1.148|
;;;180    	{
;;;181    		ReadDevIP();
000024  f7fffffe          BL       ReadDevIP
;;;182    		if(DevInfoObj.dev_ip[0]==0)
000028  481f              LDR      r0,|L1.168|
00002a  f8900035          LDRB     r0,[r0,#0x35]  ; DevInfoObj
00002e  b918              CBNZ     r0,|L1.56|
;;;183    		{
;;;184    			curWifiStatus = 0;
000030  2000              MOVS     r0,#0
000032  491e              LDR      r1,|L1.172|
000034  7008              STRB     r0,[r1,#0]
000036  e00f              B        |L1.88|
                  |L1.56|
;;;185    			//DevModeStatus = AP_MODE_LED;
;;;186    		}
;;;187    		else if(DevInfoObj.dev_ip[0]!=0)									//网络正常
000038  481b              LDR      r0,|L1.168|
00003a  f8900035          LDRB     r0,[r0,#0x35]  ; DevInfoObj
00003e  b158              CBZ      r0,|L1.88|
;;;188    		{	
;;;189    			curWifiStatus = 1;		
000040  2001              MOVS     r0,#1
000042  491a              LDR      r1,|L1.172|
000044  7008              STRB     r0,[r1,#0]
;;;190    		    ClrBit(DevStatusObj.LedShowStatus, WIFI_LED_SHOW_0_BIT);
000046  481a              LDR      r0,|L1.176|
000048  7800              LDRB     r0,[r0,#0]  ; DevStatusObj
00004a  f0200001          BIC      r0,r0,#1
00004e  4918              LDR      r1,|L1.176|
000050  7008              STRB     r0,[r1,#0]
;;;191    			
;;;192    			LedCtl(WIFI_LED_ON);
000052  2001              MOVS     r0,#1
000054  f7fffffe          BL       LedCtl
                  |L1.88|
;;;193    			//u_printf("Now the device network ok!!!!\n");
;;;194    		}
;;;195    
;;;196    	#if 1
;;;197    		if(lastWifiStatus != curWifiStatus)		
000058  4816              LDR      r0,|L1.180|
00005a  7800              LDRB     r0,[r0,#0]  ; lastWifiStatus
00005c  4913              LDR      r1,|L1.172|
00005e  7809              LDRB     r1,[r1,#0]  ; curWifiStatus
000060  4288              CMP      r0,r1
000062  d017              BEQ      |L1.148|
;;;198    		{		
;;;199    			if(curWifiStatus == 1)				//网络变为正常
000064  4811              LDR      r0,|L1.172|
000066  7800              LDRB     r0,[r0,#0]  ; curWifiStatus
000068  2801              CMP      r0,#1
00006a  d109              BNE      |L1.128|
;;;200    			{
;;;201    				
;;;202    				ClrBit(DevStatusObj.LedShowStatus, WIFI_LED_SHOW_0_BIT);
00006c  4810              LDR      r0,|L1.176|
00006e  7800              LDRB     r0,[r0,#0]  ; DevStatusObj
000070  f0200001          BIC      r0,r0,#1
000074  490e              LDR      r1,|L1.176|
000076  7008              STRB     r0,[r1,#0]
;;;203    				LedCtl(WIFI_LED_ON);			
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       LedCtl
00007e  e005              B        |L1.140|
                  |L1.128|
;;;204    			}
;;;205    			else
;;;206    			{
;;;207    				//DevModeStatus = AP_MODE_LED;
;;;208    				
;;;209    				SetBit(DevStatusObj.LedShowStatus, WIFI_LED_SHOW_0_BIT);			// Client LED Show 
000080  480b              LDR      r0,|L1.176|
000082  7800              LDRB     r0,[r0,#0]  ; DevStatusObj
000084  f0400001          ORR      r0,r0,#1
000088  4909              LDR      r1,|L1.176|
00008a  7008              STRB     r0,[r1,#0]
                  |L1.140|
;;;210    				//LedBlink(1);
;;;211    			}
;;;212    			lastWifiStatus = curWifiStatus;
00008c  4807              LDR      r0,|L1.172|
00008e  7800              LDRB     r0,[r0,#0]  ; curWifiStatus
000090  4908              LDR      r1,|L1.180|
000092  7008              STRB     r0,[r1,#0]
                  |L1.148|
;;;213    		}
;;;214    	#endif
;;;215    	}
;;;216    }
000094  b00e              ADD      sp,sp,#0x38
000096  bd10              POP      {r4,pc}
;;;217    
                          ENDP

                  |L1.152|
000098  41542b57          DCB      "AT+WMODE\r\n",0
00009c  4d4f4445
0000a0  0d0a00  
0000a3  00                DCB      0
                  |L1.164|
0000a4  415000            DCB      "AP",0
0000a7  00                DCB      0
                  |L1.168|
                          DCD      DevInfoObj
                  |L1.172|
                          DCD      curWifiStatus
                  |L1.176|
                          DCD      DevStatusObj
                  |L1.180|
                          DCD      lastWifiStatus

                          AREA ||i.CheckSwState||, CODE, READONLY, ALIGN=2

                  CheckSwState PROC
;;;551    
;;;552    void CheckSwState(void)
000000  2000              MOVS     r0,#0
;;;553    {
;;;554        uint8_t portID = 0;
;;;555        for(portID=0;portID<portNum;portID++)
000002  bf00              NOP      
000004  e014              B        |L2.48|
                  |L2.6|
;;;556        {
;;;557            if(SwInformation.PortInfor[portID].OldStatus != SwInformation.PortInfor[portID].CurStatus)
000006  eb000280          ADD      r2,r0,r0,LSL #2
00000a  4918              LDR      r1,|L2.108|
00000c  eb010182          ADD      r1,r1,r2,LSL #2
000010  7bca              LDRB     r2,[r1,#0xf]
000012  eb000380          ADD      r3,r0,r0,LSL #2
000016  4915              LDR      r1,|L2.108|
000018  eb010183          ADD      r1,r1,r3,LSL #2
00001c  7c09              LDRB     r1,[r1,#0x10]
00001e  428a              CMP      r2,r1
000020  d004              BEQ      |L2.44|
;;;558            {
;;;559                iSaveSwStateCount++;
000022  4913              LDR      r1,|L2.112|
000024  7809              LDRB     r1,[r1,#0]  ; iSaveSwStateCount
000026  1c49              ADDS     r1,r1,#1
000028  4a11              LDR      r2,|L2.112|
00002a  7011              STRB     r1,[r2,#0]
                  |L2.44|
00002c  1c41              ADDS     r1,r0,#1              ;555
00002e  b2c8              UXTB     r0,r1                 ;555
                  |L2.48|
000030  4910              LDR      r1,|L2.116|
000032  7809              LDRB     r1,[r1,#0]            ;555  ; portNum
000034  4288              CMP      r0,r1                 ;555
000036  dbe6              BLT      |L2.6|
;;;560            }       
;;;561        }
;;;562        
;;;563        if(iSaveSwStateCount > SAVE_SW_STATE_AFTER_CHANGE_TIME_SEC) 
000038  490d              LDR      r1,|L2.112|
00003a  7809              LDRB     r1,[r1,#0]  ; iSaveSwStateCount
00003c  2905              CMP      r1,#5
00003e  dd14              BLE      |L2.106|
;;;564        {
;;;565            iSaveSwStateCount = 0x00; 
000040  2100              MOVS     r1,#0
000042  4a0b              LDR      r2,|L2.112|
000044  7011              STRB     r1,[r2,#0]
;;;566            SwInformation.PortInfor[portID].OldStatus = SwInformation.PortInfor[portID].CurStatus; 
000046  eb000280          ADD      r2,r0,r0,LSL #2
00004a  4908              LDR      r1,|L2.108|
00004c  eb010182          ADD      r1,r1,r2,LSL #2
000050  7c0a              LDRB     r2,[r1,#0x10]
000052  eb000380          ADD      r3,r0,r0,LSL #2
000056  4905              LDR      r1,|L2.108|
000058  eb010183          ADD      r1,r1,r3,LSL #2
00005c  73ca              STRB     r2,[r1,#0xf]
;;;567            SetBit(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_14_SW_STATE_IS_DIRTY_CMD); 
00005e  4906              LDR      r1,|L2.120|
000060  6809              LDR      r1,[r1,#0]  ; FwUpdateStatusObj
000062  f4414180          ORR      r1,r1,#0x4000
000066  4a04              LDR      r2,|L2.120|
000068  6011              STR      r1,[r2,#0]  ; FwUpdateStatusObj
                  |L2.106|
;;;568        }
;;;569    }
00006a  4770              BX       lr
;;;570    
                          ENDP

                  |L2.108|
                          DCD      SwInformation+0x8
                  |L2.112|
                          DCD      iSaveSwStateCount
                  |L2.116|
                          DCD      portNum
                  |L2.120|
                          DCD      FwUpdateStatusObj

                          AREA ||i.ClearDevSmartLinkInfo||, CODE, READONLY, ALIGN=1

                  ClearDevSmartLinkInfo PROC
;;;238    ******************************************************************************************************/ 
;;;239    void ClearDevSmartLinkInfo(void)
000000  b510              PUSH     {r4,lr}
;;;240    {
;;;241        hfsys_reload();
000002  f7fffffe          BL       hfsys_reload
;;;242    	//msleep(500);
;;;243        hfsys_reset();
000006  f7fffffe          BL       hfsys_reset
;;;244    }
00000a  bd10              POP      {r4,pc}
;;;245    
                          ENDP


                          AREA ||i.DevFlash_init||, CODE, READONLY, ALIGN=2

                  DevFlash_init PROC
;;;55     *******************************************************************************/ 
;;;56     void DevFlash_init(void) 
000000  2000              MOVS     r0,#0
;;;57     {
;;;58         DevBootFactory = 0x00;
000002  4901              LDR      r1,|L4.8|
000004  6008              STR      r0,[r1,#0]  ; DevBootFactory
;;;59     }
000006  4770              BX       lr
;;;60     
                          ENDP

                  |L4.8|
                          DCD      DevBootFactory

                          AREA ||i.DevMode_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  DevMode_Init PROC
;;;100    *****************************************************************************************************************/ 
;;;101    void DevMode_Init(void) 
000000  b530              PUSH     {r4,r5,lr}
;;;102    {
000002  b09d              SUB      sp,sp,#0x74
;;;103        char     AtAckMsg[BOOT_INFO_DATA_BUF_LENGTH+1]={0};
000004  2134              MOVS     r1,#0x34
000006  a810              ADD      r0,sp,#0x40
000008  f7fffffe          BL       __aeabi_memclr4
;;;104    	char 	 AtBuffer[64] = {0};
00000c  2140              MOVS     r1,#0x40
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memclr4
;;;105        char    *pS8Tmp;
;;;106    	uint8_t  iLength = 0;
000014  2500              MOVS     r5,#0
;;;107    
;;;108    
;;;109    	#if (PORT_NUM == 1)
;;;110    	 hfat_send_cmd("AT+WRMID=SmartPlug\r\n", sizeof("AT+WRMID=SmartPlug\r\n")-1, AtAckMsg, 19);
;;;111    	#elif (PORT_NUM == 6)
;;;112    	 //hfat_send_cmd("AT+WRMID=SmartStrip\r\n", sizeof("AT+WRMID=SmartStrip\r\n")-1, AtAckMsg, 19);
;;;113    	 iLength = sprintf(AtBuffer, "AT+WRMID=%s\r\n", DevInfoObj.dev_sn);       
000016  4a20              LDR      r2,|L5.152|
000018  a120              ADR      r1,|L5.156|
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       __2sprintf
000020  b2c5              UXTB     r5,r0
;;;114         hfat_send_cmd(AtBuffer, iLength, AtAckMsg, BOOT_INFO_DATA_BUF_LENGTH); 
000022  2330              MOVS     r3,#0x30
000024  aa10              ADD      r2,sp,#0x40
000026  4629              MOV      r1,r5
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       hfat_send_cmd
;;;115    	#endif
;;;116    
;;;117        hfat_send_cmd("AT+WMODE\r\n", sizeof("AT+WMODE\r\n")-1, AtAckMsg, 19);
00002e  2313              MOVS     r3,#0x13
000030  aa10              ADD      r2,sp,#0x40
000032  210a              MOVS     r1,#0xa
000034  a01d              ADR      r0,|L5.172|
000036  f7fffffe          BL       hfat_send_cmd
;;;118        pS8Tmp = strstr(AtAckMsg, "AP"); 
00003a  a11f              ADR      r1,|L5.184|
00003c  a810              ADD      r0,sp,#0x40
00003e  f7fffffe          BL       strstr
000042  4604              MOV      r4,r0
;;;119    
;;;120    	//u_printf("AtAckMsg = %s\n",AtAckMsg);
;;;121    	//u_printf("factoryProgramMark = %d\n",factoryProgramMark);
;;;122    	
;;;123    	//没有找到"AP"
;;;124        if(NULL == pS8Tmp)
000044  b94c              CBNZ     r4,|L5.90|
;;;125        {
;;;126            SetBit(DevStatusObj.LedShowStatus, WIFI_LED_SHOW_0_BIT);            // Client LED Show 
000046  481d              LDR      r0,|L5.188|
000048  7800              LDRB     r0,[r0,#0]  ; DevStatusObj
00004a  f0400001          ORR      r0,r0,#1
00004e  491b              LDR      r1,|L5.188|
000050  7008              STRB     r0,[r1,#0]
;;;127            DevModeStatus = CLIENT_MODE_LED;
000052  2002              MOVS     r0,#2
000054  491a              LDR      r1,|L5.192|
000056  6008              STR      r0,[r1,#0]  ; DevModeStatus
000058  e01b              B        |L5.146|
                  |L5.90|
;;;128            //SetBit(DevStatusObj.LedShowStatus, WIFI_LED_SHOW_0_BIT);            // Client LED Show 
;;;129    
;;;130        }
;;;131        else
;;;132        {
;;;133    		//if(NULL == strstr(AtAckMsg, "APSTA"))
;;;134    		{
;;;135    	        if(!factoryProgramMark)
00005a  481a              LDR      r0,|L5.196|
00005c  7800              LDRB     r0,[r0,#0]  ; factoryProgramMark
00005e  b990              CBNZ     r0,|L5.134|
;;;136    			{
;;;137    				hfat_send_cmd("AT+WMODE=STA\r\n", sizeof("AT+WMODE=STA\r\n")-1, AtAckMsg, 48);
000060  2330              MOVS     r3,#0x30
000062  aa10              ADD      r2,sp,#0x40
000064  210e              MOVS     r1,#0xe
000066  a018              ADR      r0,|L5.200|
000068  f7fffffe          BL       hfat_send_cmd
;;;138    				hfat_send_cmd("AT+WSSSID=UPGRADE-AP\r\n", sizeof("AT+WSSSID=UPGRADE-AP\r\n")-1, AtAckMsg, 48);
00006c  2330              MOVS     r3,#0x30
00006e  aa10              ADD      r2,sp,#0x40
000070  2116              MOVS     r1,#0x16
000072  a019              ADR      r0,|L5.216|
000074  f7fffffe          BL       hfat_send_cmd
;;;139    				//hfat_send_cmd("AT+WSKEY=WPA2PSK,AES,revogi2013\r\n", sizeof("AT+WSKEY=WPA2PSK,AES,revogi2013\r\n")-1, AtAckMsg, 48);
;;;140    				
;;;141    				hfat_send_cmd("AT+Z\r\n", sizeof("AT+Z\r\n")-1, AtAckMsg, 48); 
000078  2330              MOVS     r3,#0x30
00007a  aa10              ADD      r2,sp,#0x40
00007c  2106              MOVS     r1,#6
00007e  a01c              ADR      r0,|L5.240|
000080  f7fffffe          BL       hfat_send_cmd
000084  e005              B        |L5.146|
                  |L5.134|
;;;142    				
;;;143    			}
;;;144    			else
;;;145    			{
;;;146    	        	hfat_send_cmd("AT+SMTLK\r\n", sizeof("AT+SMTLK\r\n")-1, AtAckMsg, BOOT_INFO_DATA_BUF_LENGTH);       //进入smart_link模式
000086  2330              MOVS     r3,#0x30
000088  aa10              ADD      r2,sp,#0x40
00008a  210a              MOVS     r1,#0xa
00008c  a01a              ADR      r0,|L5.248|
00008e  f7fffffe          BL       hfat_send_cmd
                  |L5.146|
;;;147    	        	//DevModeStatus = SMTLINK_MODE_LED;
;;;148    			}
;;;149    
;;;150    	      #if 0
;;;151    	        //恢复出场后，要打开端口开关
;;;152    	        #if (PORT_NUM == 6)
;;;153    	    	  Switch_TurnOnOff(0, 1);
;;;154    	    	#elif (PORT_NUM == 1)
;;;155    	    	  Port_TurnOnOff(1);
;;;156    	    	#endif
;;;157    	      #endif
;;;158    		}
;;;159        }
;;;160    }
000092  b01d              ADD      sp,sp,#0x74
000094  bd30              POP      {r4,r5,pc}
;;;161    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      DevInfoObj+0x7
                  |L5.156|
00009c  41542b57          DCB      "AT+WRMID=%s\r\n",0
0000a0  524d4944
0000a4  3d25730d
0000a8  0a00    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L5.172|
0000ac  41542b57          DCB      "AT+WMODE\r\n",0
0000b0  4d4f4445
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L5.184|
0000b8  415000            DCB      "AP",0
0000bb  00                DCB      0
                  |L5.188|
                          DCD      DevStatusObj
                  |L5.192|
                          DCD      DevModeStatus
                  |L5.196|
                          DCD      factoryProgramMark
                  |L5.200|
0000c8  41542b57          DCB      "AT+WMODE=STA\r\n",0
0000cc  4d4f4445
0000d0  3d535441
0000d4  0d0a00  
0000d7  00                DCB      0
                  |L5.216|
0000d8  41542b57          DCB      "AT+WSSSID=UPGRADE-AP\r\n",0
0000dc  53535349
0000e0  443d5550
0000e4  47524144
0000e8  452d4150
0000ec  0d0a00  
0000ef  00                DCB      0
                  |L5.240|
0000f0  41542b5a          DCB      "AT+Z\r\n",0
0000f4  0d0a00  
0000f7  00                DCB      0
                  |L5.248|
0000f8  41542b53          DCB      "AT+SMTLK\r\n",0
0000fc  4d544c4b
000100  0d0a00  
000103  00                DCB      0

                          AREA ||i.EnterAPSTAMode||, CODE, READONLY, ALIGN=2

                  EnterAPSTAMode PROC
;;;225    ******************************************************************************************************/ 
;;;226    void EnterAPSTAMode(void)
000000  b500              PUSH     {lr}
;;;227    {
000002  b08d              SUB      sp,sp,#0x34
;;;228    	char	 AtAckMsg[BOOT_INFO_DATA_BUF_LENGTH+1]={0};
000004  2134              MOVS     r1,#0x34
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;229    	hfat_send_cmd("AT+WMODE=APSTA\r\n", sizeof("AT+WMODE=APSTA\r\n")-1, AtAckMsg, 48);
00000c  2330              MOVS     r3,#0x30
00000e  466a              MOV      r2,sp
000010  2110              MOVS     r1,#0x10
000012  a002              ADR      r0,|L6.28|
000014  f7fffffe          BL       hfat_send_cmd
;;;230    }
000018  b00d              ADD      sp,sp,#0x34
00001a  bd00              POP      {pc}
;;;231    
                          ENDP

                  |L6.28|
00001c  41542b57          DCB      "AT+WMODE=APSTA\r\n",0
000020  4d4f4445
000024  3d415053
000028  54410d0a
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.FlashBackupCpy||, CODE, READONLY, ALIGN=1

                  FlashBackupCpy PROC
;;;747    *******************************************************************************/ 
;;;748    int FlashBackupCpy(uint32_t dstaddr, uint32_t srcaddr, uint32_t len) 
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;749    { 
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;750        char     buf[16]; 
;;;751        uint32_t i,rlen; 
;;;752    
;;;753        for(i=0; i<len; ) 
00000a  2400              MOVS     r4,#0
00000c  e016              B        |L7.60|
                  |L7.14|
;;;754        { 
;;;755            if(i>=len) 
00000e  42ac              CMP      r4,r5
000010  d300              BCC      |L7.20|
;;;756            { 
;;;757                break; 
000012  e015              B        |L7.64|
                  |L7.20|
;;;758            } 
;;;759            else if(i+16>len) 
000014  f1040010          ADD      r0,r4,#0x10
000018  42a8              CMP      r0,r5
00001a  d902              BLS      |L7.34|
;;;760            { 
;;;761                rlen = len-i; 
00001c  eba50804          SUB      r8,r5,r4
000020  e001              B        |L7.38|
                  |L7.34|
;;;762            } 
;;;763            else 
;;;764            { 
;;;765                rlen = 16; 
000022  f04f0810          MOV      r8,#0x10
                  |L7.38|
;;;766            } 
;;;767            hfuflash_read(srcaddr+i, buf, rlen); 
000026  1938              ADDS     r0,r7,r4
000028  4642              MOV      r2,r8
00002a  4669              MOV      r1,sp
00002c  f7fffffe          BL       hfuflash_read
;;;768            hfuflash_write(dstaddr+i, buf, rlen); 
000030  1930              ADDS     r0,r6,r4
000032  4642              MOV      r2,r8
000034  4669              MOV      r1,sp
000036  f7fffffe          BL       hfuflash_write
;;;769            i += rlen; 
00003a  4444              ADD      r4,r4,r8
                  |L7.60|
00003c  42ac              CMP      r4,r5                 ;753
00003e  d3e6              BCC      |L7.14|
                  |L7.64|
000040  bf00              NOP                            ;757
;;;770        }
;;;771        return len; 
000042  4628              MOV      r0,r5
;;;772    }
000044  b004              ADD      sp,sp,#0x10
000046  e8bd81f0          POP      {r4-r8,pc}
;;;773    /*******************************************************************************
                          ENDP


                          AREA ||i.FlashResetFactory||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  FlashResetFactory PROC
;;;651    *************************************************************************************************************/ 
;;;652    void FlashResetFactory(void) 
000000  b530              PUSH     {r4,r5,lr}
;;;653    { 
000002  b09f              SUB      sp,sp,#0x7c
;;;654        char     AtAckMsg[BOOT_INFO_DATA_BUF_LENGTH+1]={0}; 
000004  2134              MOVS     r1,#0x34
000006  a812              ADD      r0,sp,#0x48
000008  f7fffffe          BL       __aeabi_memclr4
;;;655        char     ModifyNameArr[64];
;;;656        char     *pTmp; 
;;;657        int      iLength; 
;;;658    	
;;;659    	
;;;660        
;;;661        hfat_send_cmd("AT+WSMAC\r\n", sizeof("AT+WSMAC\r\n")-1, AtAckMsg, 19); 
00000c  2313              MOVS     r3,#0x13
00000e  aa12              ADD      r2,sp,#0x48
000010  210a              MOVS     r1,#0xa
000012  a03d              ADR      r0,|L8.264|
000014  f7fffffe          BL       hfat_send_cmd
;;;662        pTmp    = strstr(AtAckMsg, "+ok=");
000018  a13e              ADR      r1,|L8.276|
00001a  a812              ADD      r0,sp,#0x48
00001c  f7fffffe          BL       strstr
000020  4604              MOV      r4,r0
;;;663        memset(DevInfoObj.dev_name, '\0', NAME_LENGTH); 
000022  210f              MOVS     r1,#0xf
000024  483d              LDR      r0,|L8.284|
000026  f7fffffe          BL       __aeabi_memclr
;;;664        if(pTmp) 
00002a  b1ac              CBZ      r4,|L8.88|
;;;665        { 
;;;666            pTmp += sizeof("+ok=")-1;
00002c  1d24              ADDS     r4,r4,#4
;;;667            pTmp += 8; 
00002e  3408              ADDS     r4,r4,#8
;;;668            #if (VENDOR_CODE == VENDOR_MCL) 
;;;669        	iLength = sprintf(ModifyNameArr, "AT+WAP=11BGN,PRISEWIFI-%s,CH1\r\n", pTmp); 
;;;670            #warning "Vendor is MCL, device name is PRISEWIFI, SSID is PRISEWIFI-xxxx" 
;;;671            #elif (VENDOR_CODE == VENDOR_REVOGI) 
;;;672        	iLength = sprintf(ModifyNameArr, "AT+WAP=11BGN,SmartStrip-%s,CH1\r\n", pTmp); 
000030  4622              MOV      r2,r4
000032  a13b              ADR      r1,|L8.288|
000034  a802              ADD      r0,sp,#8
000036  f7fffffe          BL       __2sprintf
00003a  4605              MOV      r5,r0
;;;673            #warning "Vendor is revogi, device name is SmartPlug, SSID is SmartPlug-xxxx" 
;;;674            #elif (VENDOR_CODE == VENDOR_EXTEL) 
;;;675        	iLength = sprintf(ModifyNameArr, "AT+WAP=11BGN,SOKY-%s,CH1\r\n", pTmp); 
;;;676            #warning "Vendor is Extel, device name is SOKY-XXXX, SSID is SOKY-xxxx" 
;;;677            #endif 
;;;678            //snprintf((char*)&DevInfoObj.dev_name[0], NAME_LENGTH+1, "%s-%s", DEV_DEFAULT_NAME, pTmp);
;;;679            snprintf((char*)&DevInfoObj.dev_name[0], NAME_LENGTH+1, "%s-%s", dev_default_name, pTmp);  
00003c  4b41              LDR      r3,|L8.324|
00003e  a242              ADR      r2,|L8.328|
000040  2110              MOVS     r1,#0x10
000042  4836              LDR      r0,|L8.284|
000044  9400              STR      r4,[sp,#0]
000046  f7fffffe          BL       __2snprintf
;;;680            hfat_send_cmd(ModifyNameArr, iLength, AtAckMsg, BOOT_INFO_DATA_BUF_LENGTH); 
00004a  2330              MOVS     r3,#0x30
00004c  aa12              ADD      r2,sp,#0x48
00004e  4629              MOV      r1,r5
000050  a802              ADD      r0,sp,#8
000052  f7fffffe          BL       hfat_send_cmd
000056  e004              B        |L8.98|
                  |L8.88|
;;;681        } 
;;;682        else 
;;;683        { 
;;;684            //memcpy(DevInfoObj.dev_name, DEV_DEFAULT_NAME, sizeof(DEV_DEFAULT_NAME)-1);
;;;685            memcpy(DevInfoObj.dev_name, dev_default_name, NAME_LENGTH); 
000058  220f              MOVS     r2,#0xf
00005a  493a              LDR      r1,|L8.324|
00005c  482f              LDR      r0,|L8.284|
00005e  f7fffffe          BL       __aeabi_memcpy
                  |L8.98|
;;;686        } 
;;;687    
;;;688      #if (PORT_NUM == 6)
;;;689        memcpy(SwInformation.PortInfor[0].name, "PORT1", sizeof("PORT1")-1);
000062  483b              LDR      r0,|L8.336|
000064  a13b              ADR      r1,|L8.340|
000066  680a              LDR      r2,[r1,#0]
000068  6082              STR      r2,[r0,#8]  ; SwInformation
00006a  7909              LDRB     r1,[r1,#4]
00006c  7301              STRB     r1,[r0,#0xc]
;;;690        memcpy(SwInformation.PortInfor[1].name, "PORT2", sizeof("PORT2")-1);
00006e  a13b              ADR      r1,|L8.348|
000070  680a              LDR      r2,[r1,#0]
000072  61c2              STR      r2,[r0,#0x1c]
000074  7909              LDRB     r1,[r1,#4]
000076  f8801020          STRB     r1,[r0,#0x20]
;;;691        memcpy(SwInformation.PortInfor[2].name, "PORT3", sizeof("PORT3")-1);
00007a  a13a              ADR      r1,|L8.356|
00007c  680a              LDR      r2,[r1,#0]
00007e  6302              STR      r2,[r0,#0x30]
000080  7909              LDRB     r1,[r1,#4]
000082  f8801034          STRB     r1,[r0,#0x34]
;;;692        memcpy(SwInformation.PortInfor[3].name, "PORT4", sizeof("PORT4")-1);
000086  a139              ADR      r1,|L8.364|
000088  680a              LDR      r2,[r1,#0]
00008a  6442              STR      r2,[r0,#0x44]
00008c  7909              LDRB     r1,[r1,#4]
00008e  f8801048          STRB     r1,[r0,#0x48]
;;;693        memcpy(SwInformation.PortInfor[4].name, "PORT5", sizeof("PORT5")-1);
000092  a138              ADR      r1,|L8.372|
000094  680a              LDR      r2,[r1,#0]
000096  6582              STR      r2,[r0,#0x58]
000098  7909              LDRB     r1,[r1,#4]
00009a  f880105c          STRB     r1,[r0,#0x5c]
;;;694        memcpy(SwInformation.PortInfor[5].name, "PORT6", sizeof("PORT6")-1);
00009e  a137              ADR      r1,|L8.380|
0000a0  680a              LDR      r2,[r1,#0]
0000a2  66c2              STR      r2,[r0,#0x6c]
0000a4  7909              LDRB     r1,[r1,#4]
0000a6  f8801070          STRB     r1,[r0,#0x70]
;;;695     #endif
;;;696        // Reset DeviceName and port name 
;;;697       
;;;698        WriteDevName();  
0000aa  f7fffffe          BL       WriteDevName
;;;699    
;;;700     	factoryProgramMark = 1;
0000ae  2001              MOVS     r0,#1
0000b0  4934              LDR      r1,|L8.388|
0000b2  7008              STRB     r0,[r1,#0]
;;;701    	WriteDevTimeZone();
0000b4  f7fffffe          BL       WriteDevTimeZone
;;;702    
;;;703    	//hfat_send_cmd("AT+WMODE=AP\r\n", sizeof("AT+WMODE=AP\r\n")-1, AtAckMsg, 48);
;;;704    	//hfat_send_cmd("AT+SMTLK\r\n", sizeof("AT+SMTLK\r\n")-1, AtAckMsg, BOOT_INFO_DATA_BUF_LENGTH);       //进入smart_link模式
;;;705    
;;;706        hfuflash_erase_page(FLASH_DEV_RULE_INFO_BUF_START, 1);              // erase rule information 
0000b8  2101              MOVS     r1,#1
0000ba  f44f5040          MOV      r0,#0x3000
0000be  f7fffffe          BL       hfuflash_erase_page
;;;707        hfuflash_erase_page(FLASH_DEV_BIND_BUF_START, 1);                  //erase regidID information:1KB
0000c2  2101              MOVS     r1,#1
0000c4  2000              MOVS     r0,#0
0000c6  f7fffffe          BL       hfuflash_erase_page
;;;708        hfuflash_erase_page(FLASH_DEV_STATUS_INFO_BUF_START, 1);			// erase the MS/Reboot port information
0000ca  2101              MOVS     r1,#1
0000cc  f44f40a0          MOV      r0,#0x5000
0000d0  f7fffffe          BL       hfuflash_erase_page
;;;709    	hfuflash_erase_page(FLASH_DEV_SECURITY_INFO_BUF_START, 1);
0000d4  2101              MOVS     r1,#1
0000d6  f44f4040          MOV      r0,#0xc000
0000da  f7fffffe          BL       hfuflash_erase_page
;;;710    
;;;711    	
;;;712    
;;;713    #if 1
;;;714       #if(PORT_NUM == 1)
;;;715       	if(!SwInformation.PortInfor[0].CurStatus)
;;;716       	{
;;;717    		//SwInformation.PortInfor[0].CurStatus = 1;
;;;718    		Port_TurnOnOff(1);
;;;719       	}
;;;720       #elif(PORT_NUM == 6)
;;;721       {
;;;722       		//uint8_t i = 0;
;;;723    		
;;;724       		//for(i=0;i<PORT_NUM;i++)
;;;725       		{
;;;726    		//	SwInformation.PortInfor[i].CurStatus = 1;
;;;727       		}
;;;728    
;;;729    		Switch_TurnOnOff(0,1);
0000de  2101              MOVS     r1,#1
0000e0  2000              MOVS     r0,#0
0000e2  f7fffffe          BL       Switch_TurnOnOff
;;;730       }
;;;731       #endif
;;;732       
;;;733       SetBit(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_14_SW_STATE_IS_DIRTY_CMD);   //save the master status to flash
0000e6  4828              LDR      r0,|L8.392|
0000e8  6800              LDR      r0,[r0,#0]  ; FwUpdateStatusObj
0000ea  f4404080          ORR      r0,r0,#0x4000
0000ee  4926              LDR      r1,|L8.392|
0000f0  6008              STR      r0,[r1,#0]  ; FwUpdateStatusObj
;;;734       SaveDevStatusPoll();
0000f2  f7fffffe          BL       SaveDevStatusPoll
;;;735    #endif
;;;736    	msleep(500);
0000f6  f44f70fa          MOV      r0,#0x1f4
0000fa  f7fffffe          BL       hf_thread_delay
;;;737        ClearDevSmartLinkInfo();                //擦除之前保存的WIFI配置信息，设备将重新进入smart_link模式
0000fe  f7fffffe          BL       ClearDevSmartLinkInfo
;;;738    } 
000102  b01f              ADD      sp,sp,#0x7c
000104  bd30              POP      {r4,r5,pc}
;;;739    
                          ENDP

000106  0000              DCW      0x0000
                  |L8.264|
000108  41542b57          DCB      "AT+WSMAC\r\n",0
00010c  534d4143
000110  0d0a00  
000113  00                DCB      0
                  |L8.276|
000114  2b6f6b3d          DCB      "+ok=",0
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L8.284|
                          DCD      DevInfoObj+0x25
                  |L8.288|
000120  41542b57          DCB      "AT+WAP=11BGN,SmartStrip-%s,CH1\r\n",0
000124  41503d31
000128  3142474e
00012c  2c536d61
000130  72745374
000134  7269702d
000138  25732c43
00013c  48310d0a
000140  00      
000141  00                DCB      0
000142  00                DCB      0
000143  00                DCB      0
                  |L8.324|
                          DCD      dev_default_name
                  |L8.328|
000148  25732d25          DCB      "%s-%s",0
00014c  7300    
00014e  00                DCB      0
00014f  00                DCB      0
                  |L8.336|
                          DCD      SwInformation
                  |L8.340|
000154  504f5254          DCB      "PORT1",0
000158  3100    
00015a  00                DCB      0
00015b  00                DCB      0
                  |L8.348|
00015c  504f5254          DCB      "PORT2",0
000160  3200    
000162  00                DCB      0
000163  00                DCB      0
                  |L8.356|
000164  504f5254          DCB      "PORT3",0
000168  3300    
00016a  00                DCB      0
00016b  00                DCB      0
                  |L8.364|
00016c  504f5254          DCB      "PORT4",0
000170  3400    
000172  00                DCB      0
000173  00                DCB      0
                  |L8.372|
000174  504f5254          DCB      "PORT5",0
000178  3500    
00017a  00                DCB      0
00017b  00                DCB      0
                  |L8.380|
00017c  504f5254          DCB      "PORT6",0
000180  3600    
000182  00                DCB      0
000183  00                DCB      0
                  |L8.388|
                          DCD      factoryProgramMark
                  |L8.392|
                          DCD      FwUpdateStatusObj

                          AREA ||i.ReadDevName||, CODE, READONLY, ALIGN=2

                  ReadDevName PROC
;;;286    ******************************************************************************************************/ 
;;;287    void ReadDevName(void)
000000  b570              PUSH     {r4-r6,lr}
;;;288    {
000002  b09c              SUB      sp,sp,#0x70
;;;289        char    DevInfoFlashArr[NAME_LENGTH*(PORT_NUM+1)+1+4] = {0};      //port name and device name
000004  2170              MOVS     r1,#0x70
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;290        char    *pTmpBuf;
;;;291        int     *pTmp;
;;;292        uint8_t portID = 0;
00000c  2500              MOVS     r5,#0
;;;293        
;;;294        hfuflash_read(FLASH_DEV_NAME_BUF_START, DevInfoFlashArr, sizeof(DevInfoFlashArr));
00000e  226e              MOVS     r2,#0x6e
000010  4669              MOV      r1,sp
000012  f44f4000          MOV      r0,#0x8000
000016  f7fffffe          BL       hfuflash_read
;;;295        pTmp = (int*)DevInfoFlashArr;
00001a  466e              MOV      r6,sp
;;;296        if(FLASH_DEV_NAME_FLAG == *pTmp)
00001c  6830              LDR      r0,[r6,#0]
00001e  f1b03f12          CMP      r0,#0x12121212
000022  d118              BNE      |L9.86|
;;;297        {
;;;298            pTmpBuf  = &DevInfoFlashArr[0];
000024  466c              MOV      r4,sp
;;;299            pTmpBuf += FLASH_DEV_NAME_OFFSET;
000026  1d24              ADDS     r4,r4,#4
;;;300            memcpy(DevInfoObj.dev_name, pTmpBuf, NAME_LENGTH);
000028  220f              MOVS     r2,#0xf
00002a  4621              MOV      r1,r4
00002c  4820              LDR      r0,|L9.176|
00002e  f7fffffe          BL       __aeabi_memcpy
;;;301            //read the port name 
;;;302            pTmpBuf += NAME_LENGTH;
000032  340f              ADDS     r4,r4,#0xf
;;;303            for(portID=0;portID<PORT_NUM;portID++)
000034  bf00              NOP      
000036  e00b              B        |L9.80|
                  |L9.56|
;;;304            {
;;;305                memcpy(SwInformation.PortInfor[portID].name,pTmpBuf,NAME_LENGTH);
000038  eb050285          ADD      r2,r5,r5,LSL #2
00003c  491d              LDR      r1,|L9.180|
00003e  eb010082          ADD      r0,r1,r2,LSL #2
000042  220f              MOVS     r2,#0xf
000044  4621              MOV      r1,r4
000046  f7fffffe          BL       __aeabi_memcpy
;;;306                pTmpBuf += NAME_LENGTH; 
00004a  340f              ADDS     r4,r4,#0xf
00004c  1c68              ADDS     r0,r5,#1              ;303
00004e  b2c5              UXTB     r5,r0                 ;303
                  |L9.80|
000050  2d06              CMP      r5,#6                 ;303
000052  dbf1              BLT      |L9.56|
000054  e029              B        |L9.170|
                  |L9.86|
;;;307                //u_printf("PortInfor[%d] = %s\n",portID,SwInformation.PortInfor[portID].name);
;;;308            }
;;;309        }
;;;310        else
;;;311        {
;;;312            //memcpy(DevInfoObj.dev_name, DEV_DEFAULT_NAME, sizeof(DEV_DEFAULT_NAME)-1); 
;;;313            memcpy(DevInfoObj.dev_name, dev_default_name, NAME_LENGTH); 
000056  220f              MOVS     r2,#0xf
000058  4917              LDR      r1,|L9.184|
00005a  4815              LDR      r0,|L9.176|
00005c  f7fffffe          BL       __aeabi_memcpy
;;;314           #if (PORT_NUM == 6)
;;;315            memcpy(SwInformation.PortInfor[0].name, "PORT1", sizeof("PORT1")-1);
000060  4814              LDR      r0,|L9.180|
000062  3808              SUBS     r0,r0,#8
000064  a115              ADR      r1,|L9.188|
000066  680a              LDR      r2,[r1,#0]
000068  6082              STR      r2,[r0,#8]  ; SwInformation
00006a  7909              LDRB     r1,[r1,#4]
00006c  7301              STRB     r1,[r0,#0xc]
;;;316            memcpy(SwInformation.PortInfor[1].name, "PORT2", sizeof("PORT2")-1);
00006e  a115              ADR      r1,|L9.196|
000070  680a              LDR      r2,[r1,#0]
000072  61c2              STR      r2,[r0,#0x1c]
000074  7909              LDRB     r1,[r1,#4]
000076  f8801020          STRB     r1,[r0,#0x20]
;;;317            memcpy(SwInformation.PortInfor[2].name, "PORT3", sizeof("PORT3")-1);
00007a  a114              ADR      r1,|L9.204|
00007c  680a              LDR      r2,[r1,#0]
00007e  6302              STR      r2,[r0,#0x30]
000080  7909              LDRB     r1,[r1,#4]
000082  f8801034          STRB     r1,[r0,#0x34]
;;;318            memcpy(SwInformation.PortInfor[3].name, "PORT4", sizeof("PORT4")-1);
000086  a113              ADR      r1,|L9.212|
000088  680a              LDR      r2,[r1,#0]
00008a  6442              STR      r2,[r0,#0x44]
00008c  7909              LDRB     r1,[r1,#4]
00008e  f8801048          STRB     r1,[r0,#0x48]
;;;319            memcpy(SwInformation.PortInfor[4].name, "PORT5", sizeof("PORT5")-1);
000092  a112              ADR      r1,|L9.220|
000094  680a              LDR      r2,[r1,#0]
000096  6582              STR      r2,[r0,#0x58]
000098  7909              LDRB     r1,[r1,#4]
00009a  f880105c          STRB     r1,[r0,#0x5c]
;;;320            memcpy(SwInformation.PortInfor[5].name, "PORT6", sizeof("PORT6")-1);
00009e  a111              ADR      r1,|L9.228|
0000a0  680a              LDR      r2,[r1,#0]
0000a2  66c2              STR      r2,[r0,#0x6c]
0000a4  7909              LDRB     r1,[r1,#4]
0000a6  f8801070          STRB     r1,[r0,#0x70]
                  |L9.170|
;;;321           #endif
;;;322        }
;;;323    }
0000aa  b01c              ADD      sp,sp,#0x70
0000ac  bd70              POP      {r4-r6,pc}
;;;324    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L9.176|
                          DCD      DevInfoObj+0x25
                  |L9.180|
                          DCD      SwInformation+0x8
                  |L9.184|
                          DCD      dev_default_name
                  |L9.188|
0000bc  504f5254          DCB      "PORT1",0
0000c0  3100    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L9.196|
0000c4  504f5254          DCB      "PORT2",0
0000c8  3200    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L9.204|
0000cc  504f5254          DCB      "PORT3",0
0000d0  3300    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L9.212|
0000d4  504f5254          DCB      "PORT4",0
0000d8  3400    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L9.220|
0000dc  504f5254          DCB      "PORT5",0
0000e0  3500    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L9.228|
0000e4  504f5254          DCB      "PORT6",0
0000e8  3600    
0000ea  00                DCB      0
0000eb  00                DCB      0

                          AREA ||i.ReadDevRule||, CODE, READONLY, ALIGN=2

                  ReadDevRule PROC
;;;606    extern FwUpdateStatusType   FwUpdateStatusObj; 
;;;607    void ReadDevRule(void) 
000000  b510              PUSH     {r4,lr}
;;;608    { 
;;;609        char  *pBufRule; 
;;;610        
;;;611        pBufRule = (char*)&DevRuleInfoObj; 
000002  4c09              LDR      r4,|L10.40|
;;;612        hfuflash_read(FLASH_DEV_RULE_INFO_BUF_START, pBufRule, sizeof(DevRuleInfoType));
000004  f44f72d4          MOV      r2,#0x1a8
000008  4621              MOV      r1,r4
00000a  f44f5040          MOV      r0,#0x3000
00000e  f7fffffe          BL       hfuflash_read
;;;613        if(FLASH_DEV_RULE_FLAG != DevRuleInfoObj.isRuleSaveFlag) 
000012  4620              MOV      r0,r4
000014  6840              LDR      r0,[r0,#4]  ; DevRuleInfoObj
000016  4905              LDR      r1,|L10.44|
000018  4288              CMP      r0,r1
00001a  d004              BEQ      |L10.38|
;;;614        {
;;;615            memset(&DevRuleInfoObj, '\0', sizeof(DevRuleInfoType));
00001c  f44f71d4          MOV      r1,#0x1a8
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       __aeabi_memclr4
                  |L10.38|
;;;616        }
;;;617    } 
000026  bd10              POP      {r4,pc}
;;;618    
                          ENDP

                  |L10.40|
                          DCD      DevRuleInfoObj
                  |L10.44|
                          DCD      0x33553355

                          AREA ||i.ReadDevSakSN||, CODE, READONLY, ALIGN=2

                  ReadDevSakSN PROC
;;;415    ******************************************************************************************************/ 
;;;416    extern void ReadDevSakSN(void)
000000  b530              PUSH     {r4,r5,lr}
;;;417    {
000002  b0a1              SUB      sp,sp,#0x84
;;;418        char    DevInfoFlashArr[128+1] = {0};
000004  2184              MOVS     r1,#0x84
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;419        char    *pS8TmpBuf;
;;;420        int     *pS32Tmp;
;;;421       #if  defined(HANK_JOE_CUSTOMER_REMOTE_CTL) 
;;;422        char    iWrFlg;
;;;423        iWrFlg = 1;
;;;424       #endif 
;;;425        
;;;426        hfuflash_read(FLASH_DEV_HARD_INFO_BUF_START, DevInfoFlashArr, 128);
00000c  2280              MOVS     r2,#0x80
00000e  4669              MOV      r1,sp
000010  0190              LSLS     r0,r2,#6
000012  f7fffffe          BL       hfuflash_read
;;;427        pS32Tmp = (int*)DevInfoFlashArr;
000016  466c              MOV      r4,sp
;;;428        if(FLASH_DEV_FLAG == *pS32Tmp)
000018  490d              LDR      r1,|L11.80|
00001a  6820              LDR      r0,[r4,#0]
00001c  4288              CMP      r0,r1
00001e  d107              BNE      |L11.48|
;;;429        { 
;;;430            pS8TmpBuf  = &DevInfoFlashArr[FLASH_SAK_OFFSET];
000020  ad02              ADD      r5,sp,#8
;;;431            memcpy(DevInfoObj.dev_sak, pS8TmpBuf, SAK_LEN);
000022  480c              LDR      r0,|L11.84|
000024  6829              LDR      r1,[r5,#0]
000026  6181              STR      r1,[r0,#0x18]  ; DevInfoObj
000028  6869              LDR      r1,[r5,#4]
00002a  61c1              STR      r1,[r0,#0x1c]  ; DevInfoObj
00002c  68a9              LDR      r1,[r5,#8]
00002e  6201              STR      r1,[r0,#0x20]  ; DevInfoObj
                  |L11.48|
;;;432        } 
;;;433       #if  defined(HANK_JOE_CUSTOMER_REMOTE_CTL) 
;;;434        else
;;;435        {
;;;436            iWrFlg = 0x00;                  // default 
;;;437        }
;;;438       #endif 
;;;439        // 
;;;440        pS32Tmp    = (int*)&DevInfoFlashArr[FLASH_SN_FLAG_OFFSET];
000030  ac06              ADD      r4,sp,#0x18
;;;441        if(FLASH_SN_FLAG == *pS32Tmp)
000032  6820              LDR      r0,[r4,#0]
000034  f1b03f5a          CMP      r0,#0x5a5a5a5a
000038  d107              BNE      |L11.74|
;;;442        { 
;;;443            pS32Tmp++;
00003a  1d24              ADDS     r4,r4,#4
;;;444            pS8TmpBuf = (char*)pS32Tmp; 
00003c  4625              MOV      r5,r4
;;;445            memcpy(DevInfoObj.dev_sn, pS8TmpBuf, SERIAL_NUN_ID_LEN);
00003e  2210              MOVS     r2,#0x10
000040  4629              MOV      r1,r5
000042  4804              LDR      r0,|L11.84|
000044  1dc0              ADDS     r0,r0,#7
000046  f7fffffe          BL       __aeabi_memcpy
                  |L11.74|
;;;446        } 
;;;447    #if 0
;;;448        pS32Tmp    = (int*)&DevInfoFlashArr[FLASH_REGID_FLAG_OFFSET];
;;;449        if(FLASH_REGID_FLAG == *pS32Tmp)
;;;450        { 
;;;451            pS32Tmp++;
;;;452            pS8TmpBuf = (char*)pS32Tmp; 
;;;453            memcpy(DevInfoObj.userName, pS8TmpBuf, NAME_LENGTH);
;;;454            isGetRegid = 1;             //已经获取到了设备的用户名
;;;455        } 
;;;456    #endif    
;;;457       #if  defined(HANK_JOE_CUSTOMER_REMOTE_CTL) 
;;;458        else
;;;459        {
;;;460            iWrFlg = 0x00;                  // default 
;;;461        }
;;;462        if(0x00 == iWrFlg)
;;;463        {
;;;464            WriteDevSakSN();                // default 
;;;465        }
;;;466       #endif 
;;;467    }
00004a  b021              ADD      sp,sp,#0x84
00004c  bd30              POP      {r4,r5,pc}
;;;468    
                          ENDP

00004e  0000              DCW      0x0000
                  |L11.80|
                          DCD      0x55aa55aa
                  |L11.84|
                          DCD      DevInfoObj

                          AREA ||i.ReadDevStatus||, CODE, READONLY, ALIGN=2

                  ReadDevStatus PROC
;;;520    
;;;521    void ReadDevStatus(void)
000000  b510              PUSH     {r4,lr}
;;;522    {
;;;523    	char  *pBufStatus; 
;;;524    	   
;;;525    	pBufStatus = (char*)&SwInformation; 
000002  4c0a              LDR      r4,|L12.44|
;;;526    	hfuflash_read(FLASH_DEV_STATUS_INFO_BUF_START, pBufStatus, sizeof(SwInformation));
000004  2294              MOVS     r2,#0x94
000006  4621              MOV      r1,r4
000008  f44f40a0          MOV      r0,#0x5000
00000c  f7fffffe          BL       hfuflash_read
;;;527    	if(SwInformation.isDevStatusSaveFlg != FLASH_DEV_STATUS_FLAG) 
000010  4620              MOV      r0,r4
000012  6840              LDR      r0,[r0,#4]  ; SwInformation
000014  f1b03f35          CMP      r0,#0x35353535
000018  d003              BEQ      |L12.34|
;;;528    	{
;;;529    	   memset(&SwInformation, 0, sizeof(SwInformation));
00001a  2194              MOVS     r1,#0x94
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       __aeabi_memclr4
                  |L12.34|
;;;530    	}
;;;531    	SwInformation.portChangeReason = PORT_NO_CHANGE;
000022  2000              MOVS     r0,#0
000024  4901              LDR      r1,|L12.44|
000026  70c8              STRB     r0,[r1,#3]
;;;532    
;;;533    #if(PORT_NUM == 1)
;;;534        
;;;535        Port_TurnOnOff(SwInformation.PortInfor[0].CurStatus);
;;;536    	
;;;537        plug_updata = 1;
;;;538    #endif
;;;539    }
000028  bd10              POP      {r4,pc}
;;;540    
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      SwInformation

                          AREA ||i.ReadDevTimeZone||, CODE, READONLY, ALIGN=2

                  ReadDevTimeZone PROC
;;;357    ******************************************************************************************************/ 
;;;358    void ReadDevTimeZone(void)
000000  b510              PUSH     {r4,lr}
;;;359    {
000002  b088              SUB      sp,sp,#0x20
;;;360        char    DevInfoFlashArr[26+1] = {0};
000004  211c              MOVS     r1,#0x1c
000006  a801              ADD      r0,sp,#4
000008  f7fffffe          BL       __aeabi_memclr4
;;;361        int     *pTmp;
;;;362        
;;;363        hfuflash_read(FLASH_DEV_TIME_ZONE_BUF_START, DevInfoFlashArr, 26);
00000c  221a              MOVS     r2,#0x1a
00000e  a901              ADD      r1,sp,#4
000010  f44f4020          MOV      r0,#0xa000
000014  f7fffffe          BL       hfuflash_read
;;;364        pTmp = (int*)DevInfoFlashArr;
000018  ac01              ADD      r4,sp,#4
;;;365        if(FLASH_DEV_TIME_ZONE_FLAG == *pTmp)
00001a  6820              LDR      r0,[r4,#0]
00001c  f1b03f13          CMP      r0,#0x13131313
000020  d104              BNE      |L13.44|
;;;366        {
;;;367            pTmp++;
000022  1d24              ADDS     r4,r4,#4
;;;368            DevInfoObj.TimeZone = *pTmp;
000024  7820              LDRB     r0,[r4,#0]
000026  4907              LDR      r1,|L13.68|
000028  f881003a          STRB     r0,[r1,#0x3a]
                  |L13.44|
;;;369        }
;;;370    
;;;371    	pTmp  =  (int*)&DevInfoFlashArr[FLASH_FAC_PROGRAM_FLAG_OFFSET];
00002c  f10d0416          ADD      r4,sp,#0x16
;;;372    	if(FLASH_FAC_PROGRAM_FLAG == *pTmp)
000030  6820              LDR      r0,[r4,#0]
000032  f1b03f45          CMP      r0,#0x45454545
000036  d103              BNE      |L13.64|
;;;373        {
;;;374            pTmp++;
000038  1d24              ADDS     r4,r4,#4
;;;375            factoryProgramMark = *pTmp;
00003a  7820              LDRB     r0,[r4,#0]
00003c  4902              LDR      r1,|L13.72|
00003e  7008              STRB     r0,[r1,#0]
                  |L13.64|
;;;376        }
;;;377    	
;;;378        //u_printf("TimeZone = %d		factoryProgramMark = %d\n",DevInfoObj.TimeZone,factoryProgramMark);
;;;379    }
000040  b008              ADD      sp,sp,#0x20
000042  bd10              POP      {r4,pc}
;;;380    
                          ENDP

                  |L13.68|
                          DCD      DevInfoObj
                  |L13.72|
                          DCD      factoryProgramMark

                          AREA ||i.ResetWifiMode||, CODE, READONLY, ALIGN=2

                  ResetWifiMode PROC
;;;81     *******************************************************************************/ 
;;;82     void ResetWifiMode(void)
000000  b500              PUSH     {lr}
;;;83     {
000002  b08d              SUB      sp,sp,#0x34
;;;84         char     AtAckMsg[BOOT_INFO_DATA_BUF_LENGTH+1]={0};
000004  2134              MOVS     r1,#0x34
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;85     	
;;;86         hfat_send_cmd("AT+WIFI=down\r\n", sizeof("AT+WIFI=down\r\n")-1, AtAckMsg, 19);
00000c  2313              MOVS     r3,#0x13
00000e  466a              MOV      r2,sp
000010  210e              MOVS     r1,#0xe
000012  a00a              ADR      r0,|L14.60|
000014  f7fffffe          BL       hfat_send_cmd
;;;87     	hfat_send_cmd("AT+WMODE=STA\r\n", sizeof("AT+WMODE=STA\r\n")-1, AtAckMsg, 19);
000018  2313              MOVS     r3,#0x13
00001a  466a              MOV      r2,sp
00001c  210e              MOVS     r1,#0xe
00001e  a00b              ADR      r0,|L14.76|
000020  f7fffffe          BL       hfat_send_cmd
;;;88     	hfat_send_cmd("AT+WIFI=up\r\n", sizeof("AT+WIFI=up\r\n")-1, AtAckMsg, 19);
000024  2313              MOVS     r3,#0x13
000026  466a              MOV      r2,sp
000028  210c              MOVS     r1,#0xc
00002a  a00c              ADR      r0,|L14.92|
00002c  f7fffffe          BL       hfat_send_cmd
;;;89     
;;;90     	LedCtl(WIFI_LED_ON);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       LedCtl
;;;91     }
000036  b00d              ADD      sp,sp,#0x34
000038  bd00              POP      {pc}
;;;92     
                          ENDP

00003a  0000              DCW      0x0000
                  |L14.60|
00003c  41542b57          DCB      "AT+WIFI=down\r\n",0
000040  4946493d
000044  646f776e
000048  0d0a00  
00004b  00                DCB      0
                  |L14.76|
00004c  41542b57          DCB      "AT+WMODE=STA\r\n",0
000050  4d4f4445
000054  3d535441
000058  0d0a00  
00005b  00                DCB      0
                  |L14.92|
00005c  41542b57          DCB      "AT+WIFI=up\r\n",0
000060  4946493d
000064  75700d0a
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.SaveDevRulePoll||, CODE, READONLY, ALIGN=2

                  SaveDevRulePoll PROC
;;;630    ************************************************************************************************************/ 
;;;631    void SaveDevRulePoll(void) 
000000  b510              PUSH     {r4,lr}
;;;632    { 
;;;633        char  *pBufRule; 
;;;634        
;;;635        if(0x00 == isBitSet(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_13_RULE_IS_DIRTY_CMD))
000002  480d              LDR      r0,|L15.56|
000004  8800              LDRH     r0,[r0,#0]  ; FwUpdateStatusObj
000006  f4105f00          TST      r0,#0x2000
00000a  d100              BNE      |L15.14|
                  |L15.12|
;;;636        {
;;;637            return;
;;;638        }
;;;639        ClrBit(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_13_RULE_IS_DIRTY_CMD);
;;;640        pBufRule = (char*)&DevRuleInfoObj; 
;;;641        hfuflash_erase_page(FLASH_DEV_RULE_INFO_BUF_START, 1); 
;;;642        hfuflash_write(FLASH_DEV_RULE_INFO_BUF_START, pBufRule, sizeof(DevRuleInfoType)); 
;;;643    } 
00000c  bd10              POP      {r4,pc}
                  |L15.14|
00000e  480a              LDR      r0,|L15.56|
000010  6800              LDR      r0,[r0,#0]            ;639  ; FwUpdateStatusObj
000012  f4205000          BIC      r0,r0,#0x2000         ;639
000016  4908              LDR      r1,|L15.56|
000018  6008              STR      r0,[r1,#0]            ;639  ; FwUpdateStatusObj
00001a  4c08              LDR      r4,|L15.60|
00001c  2101              MOVS     r1,#1                 ;641
00001e  f44f5040          MOV      r0,#0x3000            ;641
000022  f7fffffe          BL       hfuflash_erase_page
000026  f44f72d4          MOV      r2,#0x1a8             ;642
00002a  4621              MOV      r1,r4                 ;642
00002c  f44f5040          MOV      r0,#0x3000            ;642
000030  f7fffffe          BL       hfuflash_write
000034  bf00              NOP      
000036  e7e9              B        |L15.12|
;;;644    
                          ENDP

                  |L15.56|
                          DCD      FwUpdateStatusObj
                  |L15.60|
                          DCD      DevRuleInfoObj

                          AREA ||i.SaveDevStatusPoll||, CODE, READONLY, ALIGN=2

                  SaveDevStatusPoll PROC
;;;578    //extern int     DevModeStatus; 
;;;579    void SaveDevStatusPoll(void)
000000  b510              PUSH     {r4,lr}
;;;580    {
;;;581        char    *pSaveBuf;
;;;582       // u_printf("DevModeStatus = %d\n",DevModeStatus);
;;;583    
;;;584        if(isBitSet(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_14_SW_STATE_IS_DIRTY_CMD))	    //写flash操作和按键检测会有冲突，需间隔开
000002  480e              LDR      r0,|L16.60|
000004  8800              LDRH     r0,[r0,#0]  ; FwUpdateStatusObj
000006  f4104f80          TST      r0,#0x4000
00000a  d015              BEQ      |L16.56|
;;;585        {
;;;586            ClrBit(FwUpdateStatusObj.TimelyCheck, TIMELY_CKECK_BIT_14_SW_STATE_IS_DIRTY_CMD); 
00000c  480b              LDR      r0,|L16.60|
00000e  6800              LDR      r0,[r0,#0]  ; FwUpdateStatusObj
000010  f4204080          BIC      r0,r0,#0x4000
000014  4909              LDR      r1,|L16.60|
000016  6008              STR      r0,[r1,#0]  ; FwUpdateStatusObj
;;;587    
;;;588           // u_printf("now we save the ms_information in flash!\n");
;;;589            
;;;590            pSaveBuf = (char*)&SwInformation; 
000018  4c09              LDR      r4,|L16.64|
;;;591            SwInformation.isDevStatusSaveFlg = FLASH_DEV_STATUS_FLAG; 
00001a  f04f3035          MOV      r0,#0x35353535
00001e  4621              MOV      r1,r4
000020  6048              STR      r0,[r1,#4]  ; SwInformation
;;;592            hfuflash_erase_page(FLASH_DEV_STATUS_INFO_BUF_START, 1); 
000022  2101              MOVS     r1,#1
000024  f44f40a0          MOV      r0,#0x5000
000028  f7fffffe          BL       hfuflash_erase_page
;;;593            hfuflash_write(FLASH_DEV_STATUS_INFO_BUF_START, pSaveBuf, sizeof(SwInformationType) ); 
00002c  2294              MOVS     r2,#0x94
00002e  4621              MOV      r1,r4
000030  f44f40a0          MOV      r0,#0x5000
000034  f7fffffe          BL       hfuflash_write
                  |L16.56|
;;;594        }
;;;595    }
000038  bd10              POP      {r4,pc}
;;;596    
                          ENDP

00003a  0000              DCW      0x0000
                  |L16.60|
                          DCD      FwUpdateStatusObj
                  |L16.64|
                          DCD      SwInformation

                          AREA ||i.WriteDevBindInfo||, CODE, READONLY, ALIGN=2

                  WriteDevBindInfo PROC
;;;480    extern FwUpdateStatusType      FwUpdateStatusObj;
;;;481    extern void WriteDevBindInfo(void)
000000  b530              PUSH     {r4,r5,lr}
;;;482    {
000002  b0c1              SUB      sp,sp,#0x104
;;;483        char    DevInfoFlashArr[256] = {0}; 
000004  f44f7180          MOV      r1,#0x100
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       __aeabi_memclr4
;;;484        char    *pS8Buf; 
;;;485        int     *pS32Tmp; 
;;;486    
;;;487        if(isGetRegid)             //已经获取到了设备的用户名
00000e  4818              LDR      r0,|L17.112|
000010  7800              LDRB     r0,[r0,#0]  ; isGetRegid
000012  2800              CMP      r0,#0
000014  d02a              BEQ      |L17.108|
;;;488        {
;;;489            pS32Tmp  = (int*)DevInfoFlashArr; 
000016  ac01              ADD      r4,sp,#4
;;;490            *pS32Tmp = FLASH_REGID_FLAG; 
000018  4816              LDR      r0,|L17.116|
00001a  6020              STR      r0,[r4,#0]
;;;491            //写设备username
;;;492            pS8Buf  =  (char*)&DevInfoFlashArr[FLASH_REGID_FLAG_OFFSET];//从第8个字节开始保存设备的username
00001c  ad02              ADD      r5,sp,#8
;;;493            memcpy(pS8Buf, DevRegInformation.regidName, NAME_LENGTH);
00001e  220f              MOVS     r2,#0xf
000020  4915              LDR      r1,|L17.120|
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       __aeabi_memcpy
;;;494         
;;;495    
;;;496            if(isDevReg == IS_ON)
000028  4814              LDR      r0,|L17.124|
00002a  7800              LDRB     r0,[r0,#0]  ; isDevReg
00002c  2801              CMP      r0,#1
00002e  d113              BNE      |L17.88|
;;;497            {
;;;498                //设备是否绑定成功标志
;;;499                pS32Tmp  = (int*)&DevInfoFlashArr[FLASH_DEV_BIND_FLAG_OFFSET];
000030  ac0b              ADD      r4,sp,#0x2c
;;;500                *pS32Tmp = FLASH_DEV_BIND_FLAG;
000032  f04f3015          MOV      r0,#0x15151515
000036  6020              STR      r0,[r4,#0]
;;;501                pS32Tmp++;
000038  1d24              ADDS     r4,r4,#4
;;;502                pS8Buf   = (char *)pS32Tmp;
00003a  4625              MOV      r5,r4
;;;503                *pS8Buf =  isDevReg;
00003c  480f              LDR      r0,|L17.124|
00003e  7800              LDRB     r0,[r0,#0]  ; isDevReg
000040  7028              STRB     r0,[r5,#0]
;;;504    
;;;505                //写次服务器的端口号
;;;506                pS32Tmp  = (int *)&DevInfoFlashArr[FLASH_DEV_BIND_PORT_OFFSET];
000042  1ca4              ADDS     r4,r4,#2
;;;507                *pS32Tmp  = DevRegInformation.iSockPort;                   //端口
000044  480c              LDR      r0,|L17.120|
000046  6900              LDR      r0,[r0,#0x10]  ; DevRegInformation
000048  6020              STR      r0,[r4,#0]
;;;508                
;;;509                pS8Buf  = (char *)&DevInfoFlashArr[FLASH_DEV_BIND_URL_OFFSET];                   //url
00004a  1d25              ADDS     r5,r4,#4
;;;510                memcpy(pS8Buf, DevRegInformation.SubSvrUrl, SLAVE_SERVER_URL_MAX_LENGTH);
00004c  2220              MOVS     r2,#0x20
00004e  490a              LDR      r1,|L17.120|
000050  3114              ADDS     r1,r1,#0x14
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       __aeabi_memcpy
                  |L17.88|
;;;511            }
;;;512          
;;;513            hfuflash_erase_page(FLASH_DEV_BIND_BUF_START, 1); 
000058  2101              MOVS     r1,#1
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       hfuflash_erase_page
;;;514            hfuflash_write(FLASH_DEV_BIND_BUF_START, DevInfoFlashArr, 256); 
000060  f44f7280          MOV      r2,#0x100
000064  a901              ADD      r1,sp,#4
000066  2000              MOVS     r0,#0
000068  f7fffffe          BL       hfuflash_write
                  |L17.108|
;;;515        }
;;;516    }
00006c  b041              ADD      sp,sp,#0x104
00006e  bd30              POP      {r4,r5,pc}
;;;517    
                          ENDP

                  |L17.112|
                          DCD      isGetRegid
                  |L17.116|
                          DCD      0xa55aa55a
                  |L17.120|
                          DCD      DevRegInformation
                  |L17.124|
                          DCD      isDevReg

                          AREA ||i.WriteDevName||, CODE, READONLY, ALIGN=2

                  WriteDevName PROC
;;;252    extern DevInfoType DevInfoObj;
;;;253    void WriteDevName()
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
000002  b0a8              SUB      sp,sp,#0xa0
;;;255        char    DevInfoFlashArr[64+4+1+NAME_LENGTH*PORT_NUM] = {0}; 
000004  21a0              MOVS     r1,#0xa0
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;256        char    *pBuf; 
;;;257        int     *pTmp; 
;;;258        
;;;259        pTmp  = (int*)DevInfoFlashArr; 
00000c  466e              MOV      r6,sp
;;;260        *pTmp = FLASH_DEV_NAME_FLAG; 
00000e  f04f3012          MOV      r0,#0x12121212
000012  6030              STR      r0,[r6,#0]
;;;261        // 
;;;262        pBuf  = DevInfoFlashArr; 
000014  466c              MOV      r4,sp
;;;263        pBuf += FLASH_DEV_NAME_OFFSET; 
000016  1d24              ADDS     r4,r4,#4
;;;264        memcpy(pBuf, DevInfoObj.dev_name,NAME_LENGTH); 
000018  220f              MOVS     r2,#0xf
00001a  4911              LDR      r1,|L18.96|
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       __aeabi_memcpy
;;;265        pBuf += NAME_LENGTH;
000022  340f              ADDS     r4,r4,#0xf
;;;266    
;;;267       #if (PORT_NUM == 6)
;;;268        uint8_t portID = 0;
000024  2500              MOVS     r5,#0
;;;269        for(portID=0;portID<PORT_NUM;portID++)
000026  bf00              NOP      
000028  e00b              B        |L18.66|
                  |L18.42|
;;;270        {
;;;271            memcpy(pBuf,(char*)SwInformation.PortInfor[portID].name,NAME_LENGTH);
00002a  eb050285          ADD      r2,r5,r5,LSL #2
00002e  480d              LDR      r0,|L18.100|
000030  eb000182          ADD      r1,r0,r2,LSL #2
000034  220f              MOVS     r2,#0xf
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       __aeabi_memcpy
;;;272            pBuf += NAME_LENGTH; 
00003c  340f              ADDS     r4,r4,#0xf
00003e  1c68              ADDS     r0,r5,#1              ;269
000040  b2c5              UXTB     r5,r0                 ;269
                  |L18.66|
000042  2d06              CMP      r5,#6                 ;269
000044  dbf1              BLT      |L18.42|
;;;273        }
;;;274       #endif
;;;275        hfuflash_erase_page(FLASH_DEV_NAME_BUF_START, 1);           //erase one page :2KB
000046  2101              MOVS     r1,#1
000048  03c8              LSLS     r0,r1,#15
00004a  f7fffffe          BL       hfuflash_erase_page
;;;276        hfuflash_write(FLASH_DEV_NAME_BUF_START, DevInfoFlashArr, sizeof(DevInfoFlashArr)); 
00004e  229f              MOVS     r2,#0x9f
000050  4669              MOV      r1,sp
000052  f44f4000          MOV      r0,#0x8000
000056  f7fffffe          BL       hfuflash_write
;;;277    
;;;278    
;;;279    }
00005a  b028              ADD      sp,sp,#0xa0
00005c  bd70              POP      {r4-r6,pc}
;;;280    
                          ENDP

00005e  0000              DCW      0x0000
                  |L18.96|
                          DCD      DevInfoObj+0x25
                  |L18.100|
                          DCD      SwInformation+0x8

                          AREA ||i.WriteDevSakSN||, CODE, READONLY, ALIGN=2

                  WriteDevSakSN PROC
;;;387    extern DevInfoType DevInfoObj; 
;;;388    extern void WriteDevSakSN(void)
000000  b530              PUSH     {r4,r5,lr}
;;;389    {
000002  b0a1              SUB      sp,sp,#0x84
;;;390        char    DevInfoFlashArr[128+1] = {0}; 
000004  2184              MOVS     r1,#0x84
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;391        char    *pS8Buf; 
;;;392        int     *pS32Tmp; 
;;;393        
;;;394        // 
;;;395        pS32Tmp  = (int*)DevInfoFlashArr; 
00000c  466c              MOV      r4,sp
;;;396        *pS32Tmp = FLASH_DEV_FLAG; 
00000e  4810              LDR      r0,|L19.80|
000010  6020              STR      r0,[r4,#0]
;;;397        pS8Buf   = &DevInfoFlashArr[FLASH_SAK_OFFSET];          //从第8个字节开始保存设备的sak码
000012  ad02              ADD      r5,sp,#8
;;;398        memcpy(pS8Buf, DevInfoObj.dev_sak, SAK_LEN);
000014  480f              LDR      r0,|L19.84|
000016  6981              LDR      r1,[r0,#0x18]  ; DevInfoObj
000018  6029              STR      r1,[r5,#0]
00001a  69c1              LDR      r1,[r0,#0x1c]  ; DevInfoObj
00001c  6069              STR      r1,[r5,#4]
00001e  6a00              LDR      r0,[r0,#0x20]  ; DevInfoObj
000020  60a8              STR      r0,[r5,#8]
;;;399        // 
;;;400        pS32Tmp  =  (int*)&DevInfoFlashArr[FLASH_SN_FLAG_OFFSET];//从第24个字节开始保存设备的SN码，
000022  ac06              ADD      r4,sp,#0x18
;;;401       *pS32Tmp  =  FLASH_SN_FLAG;              //先写入SN码标志0x5A5A5A5A
000024  f04f305a          MOV      r0,#0x5a5a5a5a
000028  6020              STR      r0,[r4,#0]
;;;402        pS32Tmp++;
00002a  1d24              ADDS     r4,r4,#4
;;;403        pS8Buf   = (char*)pS32Tmp;
00002c  4625              MOV      r5,r4
;;;404        memcpy(pS8Buf, DevInfoObj.dev_sn, SERIAL_NUN_ID_LEN);
00002e  2210              MOVS     r2,#0x10
000030  4908              LDR      r1,|L19.84|
000032  1dc9              ADDS     r1,r1,#7
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       __aeabi_memcpy
;;;405    
;;;406        hfuflash_erase_page(FLASH_DEV_HARD_INFO_BUF_START, 1); 
00003a  2101              MOVS     r1,#1
00003c  0348              LSLS     r0,r1,#13
00003e  f7fffffe          BL       hfuflash_erase_page
;;;407        hfuflash_write(FLASH_DEV_HARD_INFO_BUF_START, DevInfoFlashArr, 128); 
000042  2280              MOVS     r2,#0x80
000044  4669              MOV      r1,sp
000046  0190              LSLS     r0,r2,#6
000048  f7fffffe          BL       hfuflash_write
;;;408    }
00004c  b021              ADD      sp,sp,#0x84
00004e  bd30              POP      {r4,r5,pc}
;;;409    
                          ENDP

                  |L19.80|
                          DCD      0x55aa55aa
                  |L19.84|
                          DCD      DevInfoObj

                          AREA ||i.WriteDevTimeZone||, CODE, READONLY, ALIGN=2

                  WriteDevTimeZone PROC
;;;330    ******************************************************************************************************/ 
;;;331    void WriteDevTimeZone(void)
000000  b510              PUSH     {r4,lr}
;;;332    {
000002  b088              SUB      sp,sp,#0x20
;;;333        char    DevInfoFlashArr[26+1] = {0}; 
000004  211c              MOVS     r1,#0x1c
000006  a801              ADD      r0,sp,#4
000008  f7fffffe          BL       __aeabi_memclr4
;;;334        int     *pTmp; 
;;;335        
;;;336        pTmp  = (int*)DevInfoFlashArr; 
00000c  ac01              ADD      r4,sp,#4
;;;337        *pTmp = FLASH_DEV_TIME_ZONE_FLAG; 
00000e  f04f3013          MOV      r0,#0x13131313
000012  6020              STR      r0,[r4,#0]
;;;338        // 
;;;339        pTmp++;
000014  1d24              ADDS     r4,r4,#4
;;;340        *pTmp = DevInfoObj.TimeZone;
000016  480c              LDR      r0,|L20.72|
000018  f890003a          LDRB     r0,[r0,#0x3a]  ; DevInfoObj
00001c  6020              STR      r0,[r4,#0]
;;;341    
;;;342    	//写设备工厂烧录标志
;;;343        pTmp  =  (int*)&DevInfoFlashArr[FLASH_FAC_PROGRAM_FLAG_OFFSET];//从第44个字节开始保存设备的username
00001e  340e              ADDS     r4,r4,#0xe
;;;344       *pTmp  =  FLASH_FAC_PROGRAM_FLAG;              //先写入regid保存标志0xA55AA55A
000020  f04f3045          MOV      r0,#0x45454545
000024  6020              STR      r0,[r4,#0]
;;;345        pTmp++;
000026  1d24              ADDS     r4,r4,#4
;;;346        *pTmp   = factoryProgramMark;
000028  4808              LDR      r0,|L20.76|
00002a  7800              LDRB     r0,[r0,#0]  ; factoryProgramMark
00002c  6020              STR      r0,[r4,#0]
;;;347    	
;;;348        hfuflash_erase_page(FLASH_DEV_TIME_ZONE_BUF_START, 1); 
00002e  2101              MOVS     r1,#1
000030  f44f4020          MOV      r0,#0xa000
000034  f7fffffe          BL       hfuflash_erase_page
;;;349        hfuflash_write(FLASH_DEV_TIME_ZONE_BUF_START, DevInfoFlashArr, 26); 
000038  221a              MOVS     r2,#0x1a
00003a  a901              ADD      r1,sp,#4
00003c  f44f4020          MOV      r0,#0xa000
000040  f7fffffe          BL       hfuflash_write
;;;350    }
000044  b008              ADD      sp,sp,#0x20
000046  bd10              POP      {r4,pc}
;;;351    
                          ENDP

                  |L20.72|
                          DCD      DevInfoObj
                  |L20.76|
                          DCD      factoryProgramMark

                          AREA ||.data||, DATA, ALIGN=2

                  isGetRegid
000000  00                DCB      0x00
                  factoryProgramMark
000001  00                DCB      0x00
                  curWifiStatus
000002  00                DCB      0x00
                  lastWifiStatus
000003  00                DCB      0x00
                  DevModeStatus
                          DCD      0x00000000
                  DevBootFactory
                          DCD      0x00000000
                  iSaveSwStateCount
00000c  00                DCB      0x00
