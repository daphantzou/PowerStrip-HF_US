; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\read_power.o --asm_dir=.\output\ --list_dir=.\output\ --depend=.\output\read_power.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=494 -I../sdk/1.50/include/ -I../inc -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -D__KEIL_MDK__ -D__LPB100__ --enum_is_int --omf_browse=.\output\read_power.crf ..\src\read_power.c]
                          THUMB

                          AREA ||i.RN8209_Init||, CODE, READONLY, ALIGN=1

                  RN8209_Init PROC
;;;180    *******************************************************************************/
;;;181    extern void RN8209_Init(void)
000000  b500              PUSH     {lr}
;;;182    {
000002  b085              SUB      sp,sp,#0x14
;;;183    	uint16_t data;
;;;184    	int     tmp;
;;;185    	SpiPack R8209Framemain; 
;;;186    
;;;187    	tmp = RN8209_EA_WR_EN; 
000004  20e5              MOVS     r0,#0xe5
000006  9003              STR      r0,[sp,#0xc]
;;;188    	R8209Framemain.spi_Address      = RN8209_EA_REG; 
000008  20ea              MOVS     r0,#0xea
00000a  f88d0000          STRB     r0,[sp,#0]
;;;189    	R8209Framemain.spi_Data         = (unsigned char *)&tmp; 
00000e  a803              ADD      r0,sp,#0xc
000010  9001              STR      r0,[sp,#4]
;;;190    	R8209Framemain.spi_NumberOfByte = 0x01; 
000012  2001              MOVS     r0,#1
000014  f88d0008          STRB     r0,[sp,#8]
;;;191    	SpiRn8209_WriteFrame(&R8209Framemain); 
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       SpiRn8209_WriteFrame
;;;192    
;;;193        data = 0x0073;
00001e  2073              MOVS     r0,#0x73
000020  9004              STR      r0,[sp,#0x10]
;;;194    	R8209Framemain.spi_Address      = 0x00;
000022  2000              MOVS     r0,#0
000024  f88d0000          STRB     r0,[sp,#0]
;;;195    	R8209Framemain.spi_Data         = (unsigned char *)&data;
000028  a804              ADD      r0,sp,#0x10
00002a  9001              STR      r0,[sp,#4]
;;;196    	R8209Framemain.spi_NumberOfByte = 0x02;
00002c  2002              MOVS     r0,#2
00002e  f88d0008          STRB     r0,[sp,#8]
;;;197    	SpiRn8209_WriteFrame(&R8209Framemain);
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       SpiRn8209_WriteFrame
;;;198    	
;;;199    	
;;;200    	//data[0] = 0x02;
;;;201    	//data[1] = 0x83; 				//引脚IRQ_N/ZX作为ZX脚
;;;202    	data = 0x0283;
000038  f2402083          MOV      r0,#0x283
00003c  9004              STR      r0,[sp,#0x10]
;;;203    	R8209Framemain.spi_Address      = 0x01;
00003e  2001              MOVS     r0,#1
000040  f88d0000          STRB     r0,[sp,#0]
;;;204    	R8209Framemain.spi_Data         = (unsigned char *)&data;
000044  a804              ADD      r0,sp,#0x10
000046  9001              STR      r0,[sp,#4]
;;;205    	R8209Framemain.spi_NumberOfByte = 0x02;
000048  2002              MOVS     r0,#2
00004a  f88d0008          STRB     r0,[sp,#8]
;;;206    	SpiRn8209_WriteFrame(&R8209Framemain);
00004e  4668              MOV      r0,sp
000050  f7fffffe          BL       SpiRn8209_WriteFrame
;;;207    
;;;208    
;;;209    	tmp = RN8209_EA_WR_DIS_EN; 
000054  20dc              MOVS     r0,#0xdc
000056  9003              STR      r0,[sp,#0xc]
;;;210    	R8209Framemain.spi_Address      = RN8209_EA_REG;
000058  20ea              MOVS     r0,#0xea
00005a  f88d0000          STRB     r0,[sp,#0]
;;;211    	R8209Framemain.spi_Data         = (unsigned char *)&tmp;
00005e  a803              ADD      r0,sp,#0xc
000060  9001              STR      r0,[sp,#4]
;;;212    	R8209Framemain.spi_NumberOfByte = 0x01;
000062  2001              MOVS     r0,#1
000064  f88d0008          STRB     r0,[sp,#8]
;;;213    	SpiRn8209_WriteFrame(&R8209Framemain);
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       SpiRn8209_WriteFrame
;;;214    }
00006e  b005              ADD      sp,sp,#0x14
000070  bd00              POP      {pc}
;;;215    
                          ENDP


                          AREA ||i.RN8209_READ||, CODE, READONLY, ALIGN=2

                  RN8209_READ PROC
;;;390    *******************************************************************************/
;;;391    extern void RN8209_READ(void)
000000  b500              PUSH     {lr}
;;;392    {
000002  b087              SUB      sp,sp,#0x1c
;;;393    	SpiPack R8209Framemain;
;;;394    	int     varCurrent = 0, varVolt, varPower,varFreq; 
000004  2000              MOVS     r0,#0
000006  9003              STR      r0,[sp,#0xc]
;;;395    	//char testBuffer[100] = {0};
;;;396    	
;;;397    	#if defined(__AP_PWR_DBG__)
;;;398    	static  int iRd8209GDbg=0;
;;;399    	#define DBG_LENGTH  40 
;;;400    	int     iLength;
;;;401    	char    DbgMsgArr[DBG_LENGTH]={0};
;;;402    	#endif 
;;;403    
;;;404    	// 读电流有效值 
;;;405    	varCurrent = 0;
000008  9003              STR      r0,[sp,#0xc]
;;;406    	R8209Framemain.spi_Address      = RN8209_IARMS;
00000a  2022              MOVS     r0,#0x22
00000c  f88d0010          STRB     r0,[sp,#0x10]
;;;407    	R8209Framemain.spi_Data         = (unsigned char *)&varCurrent;
000010  a803              ADD      r0,sp,#0xc
000012  9005              STR      r0,[sp,#0x14]
;;;408    	R8209Framemain.spi_NumberOfByte = 0x03;
000014  2003              MOVS     r0,#3
000016  f88d0018          STRB     r0,[sp,#0x18]
;;;409    	SpiRn8209_ReadFrame(&R8209Framemain);
00001a  a804              ADD      r0,sp,#0x10
00001c  f7fffffe          BL       SpiRn8209_ReadFrame
;;;410    
;;;411       #if defined(__AP_PWR_DBG__)
;;;412    	iRd8209GDbg++;
;;;413    	if(0x00 ==(iRd8209GDbg%10))
;;;414    	{
;;;415            iLength = snprintf(DbgMsgArr, DBG_LENGTH, "A=%d Cal_A=%d\r\n", varCurrent,PowerRecordObj[0].CurrentCoefficent);
;;;416            UdpDebugPrint(DbgMsgArr, iLength); 
;;;417    	}
;;;418       #endif 
;;;419       
;;;420    	if(varCurrent&(0x800000))
000020  9803              LDR      r0,[sp,#0xc]
000022  f4100f00          TST      r0,#0x800000
000026  d001              BEQ      |L2.44|
;;;421    	{
;;;422    		varCurrent = 0;
000028  2000              MOVS     r0,#0
00002a  9003              STR      r0,[sp,#0xc]
                  |L2.44|
;;;423    	}
;;;424    	reco_measure_data.reco_irms = varCurrent;
00002c  4947              LDR      r1,|L2.332|
00002e  9803              LDR      r0,[sp,#0xc]
000030  6008              STR      r0,[r1,#0]  ; reco_measure_data
;;;425    	PowerRecordObj[0].record_ValidCurrent  = (reco_measure_data.reco_irms*10)/(PowerRecordObj[0].CurrentCoefficent); 
000032  4608              MOV      r0,r1
000034  6800              LDR      r0,[r0,#0]  ; reco_measure_data
000036  eb000080          ADD      r0,r0,r0,LSL #2
00003a  0040              LSLS     r0,r0,#1
00003c  4944              LDR      r1,|L2.336|
00003e  6889              LDR      r1,[r1,#8]  ; PowerRecordObj
000040  fb90f0f1          SDIV     r0,r0,r1
000044  4942              LDR      r1,|L2.336|
000046  6048              STR      r0,[r1,#4]  ; PowerRecordObj
;;;426     
;;;427    	// 读电压有效值 
;;;428    	varVolt = 0;
000048  2000              MOVS     r0,#0
00004a  9002              STR      r0,[sp,#8]
;;;429    	R8209Framemain.spi_Address      = RN8209_URMS;
00004c  2024              MOVS     r0,#0x24
00004e  f88d0010          STRB     r0,[sp,#0x10]
;;;430    	R8209Framemain.spi_Data         = (unsigned char *)&varVolt;
000052  a802              ADD      r0,sp,#8
000054  9005              STR      r0,[sp,#0x14]
;;;431    	R8209Framemain.spi_NumberOfByte = 0x03;
000056  2003              MOVS     r0,#3
000058  f88d0018          STRB     r0,[sp,#0x18]
;;;432    	SpiRn8209_ReadFrame(&R8209Framemain);
00005c  a804              ADD      r0,sp,#0x10
00005e  f7fffffe          BL       SpiRn8209_ReadFrame
;;;433    	
;;;434       #if defined(__AP_PWR_DBG__)
;;;435    	if(0x00 ==(iRd8209GDbg%10))
;;;436    	{
;;;437            iLength = snprintf(DbgMsgArr, DBG_LENGTH, "V=%d Cal_V=%d\r\n", varVolt,PowerRecordObj[0].VoltCoefficent);
;;;438            UdpDebugPrint(DbgMsgArr, iLength); 
;;;439    	}
;;;440       #endif 
;;;441       
;;;442    	if(varVolt&(0x800000))
000062  9802              LDR      r0,[sp,#8]
000064  f4100f00          TST      r0,#0x800000
000068  d001              BEQ      |L2.110|
;;;443    	{
;;;444    		varVolt = 0;
00006a  2000              MOVS     r0,#0
00006c  9002              STR      r0,[sp,#8]
                  |L2.110|
;;;445    	}
;;;446    	reco_measure_data.reco_urms = varVolt;
00006e  4937              LDR      r1,|L2.332|
000070  9802              LDR      r0,[sp,#8]
000072  6048              STR      r0,[r1,#4]  ; reco_measure_data
;;;447    	PowerRecordObj[0].record_ValidVolt  = (reco_measure_data.reco_urms*10)/(PowerRecordObj[0].VoltCoefficent); 
000074  4608              MOV      r0,r1
000076  6840              LDR      r0,[r0,#4]  ; reco_measure_data
000078  eb000080          ADD      r0,r0,r0,LSL #2
00007c  0040              LSLS     r0,r0,#1
00007e  4934              LDR      r1,|L2.336|
000080  6909              LDR      r1,[r1,#0x10]  ; PowerRecordObj
000082  fb90f0f1          SDIV     r0,r0,r1
000086  4932              LDR      r1,|L2.336|
000088  60c8              STR      r0,[r1,#0xc]  ; PowerRecordObj
;;;448    
;;;449    	
;;;450    	// 读电源频率有效值 
;;;451    	varFreq = 0;
00008a  2000              MOVS     r0,#0
00008c  9000              STR      r0,[sp,#0]
;;;452    	R8209Framemain.spi_Address		= RN8209_UFreq;
00008e  2025              MOVS     r0,#0x25
000090  f88d0010          STRB     r0,[sp,#0x10]
;;;453    	R8209Framemain.spi_Data 		= (unsigned char *)&varFreq;
000094  f8cdd014          STR      sp,[sp,#0x14]
;;;454    	R8209Framemain.spi_NumberOfByte = 0x02;
000098  2002              MOVS     r0,#2
00009a  f88d0018          STRB     r0,[sp,#0x18]
;;;455    	SpiRn8209_ReadFrame(&R8209Framemain);
00009e  a804              ADD      r0,sp,#0x10
0000a0  f7fffffe          BL       SpiRn8209_ReadFrame
;;;456       
;;;457    	if(varFreq&(0x8000))
0000a4  9800              LDR      r0,[sp,#0]
0000a6  f4104f00          TST      r0,#0x8000
0000aa  d001              BEQ      |L2.176|
;;;458    	{
;;;459    		varFreq = 0;
0000ac  2000              MOVS     r0,#0
0000ae  9000              STR      r0,[sp,#0]
                  |L2.176|
;;;460    	}
;;;461    	reco_measure_data.reco_freq = varFreq;
0000b0  4926              LDR      r1,|L2.332|
0000b2  9800              LDR      r0,[sp,#0]
0000b4  6088              STR      r0,[r1,#8]  ; reco_measure_data
;;;462    
;;;463    #if 0
;;;464    	iRd8209GDbg++;
;;;465    	if(0x00 ==(iRd8209GDbg%10))
;;;466    	{
;;;467            iLength = snprintf(DbgMsgArr, DBG_LENGTH, "Frequency = %d\r\n", reco_measure_data.reco_freq);
;;;468            UdpDebugPrint(DbgMsgArr, iLength); 
;;;469    	}
;;;470    #endif
;;;471    
;;;472    	// 读有功功率 
;;;473    	varPower = 0;
0000b6  2000              MOVS     r0,#0
0000b8  9001              STR      r0,[sp,#4]
;;;474    	R8209Framemain.spi_Address      = RN8209_PowerPA;
0000ba  2026              MOVS     r0,#0x26
0000bc  f88d0010          STRB     r0,[sp,#0x10]
;;;475    	R8209Framemain.spi_Data         = (unsigned char *)&varPower;
0000c0  a801              ADD      r0,sp,#4
0000c2  9005              STR      r0,[sp,#0x14]
;;;476    	R8209Framemain.spi_NumberOfByte = 0x04;
0000c4  2004              MOVS     r0,#4
0000c6  f88d0018          STRB     r0,[sp,#0x18]
;;;477    	SpiRn8209_ReadFrame(&R8209Framemain);
0000ca  a804              ADD      r0,sp,#0x10
0000cc  f7fffffe          BL       SpiRn8209_ReadFrame
;;;478    	
;;;479    	if(varPower&0x80000000)
0000d0  9801              LDR      r0,[sp,#4]
0000d2  f0104f00          TST      r0,#0x80000000
0000d6  d001              BEQ      |L2.220|
;;;480    	{
;;;481    		varPower = 0;
0000d8  2000              MOVS     r0,#0
0000da  9001              STR      r0,[sp,#4]
                  |L2.220|
;;;482    	}
;;;483       #if defined(__AP_PWR_DBG__)       
;;;484    	if(0x00 ==(iRd8209GDbg%10))
;;;485    	{
;;;486            iLength = snprintf(DbgMsgArr, DBG_LENGTH, "P=%d Cal_P=%d\r\n", varPower,PowerRecordObj[0].PowerCoefficent);
;;;487            UdpDebugPrint(DbgMsgArr, iLength); 
;;;488    	}
;;;489       #endif 
;;;490       
;;;491    	reco_measure_data.reco_powerp = varPower;
0000dc  491b              LDR      r1,|L2.332|
0000de  9801              LDR      r0,[sp,#4]
0000e0  60c8              STR      r0,[r1,#0xc]  ; reco_measure_data
;;;492    	PowerRecordObj[0].record_ValidPower = (reco_measure_data.reco_powerp*10)/(PowerRecordObj[0].PowerCoefficent); 
0000e2  4608              MOV      r0,r1
0000e4  68c0              LDR      r0,[r0,#0xc]  ; reco_measure_data
0000e6  eb000080          ADD      r0,r0,r0,LSL #2
0000ea  0040              LSLS     r0,r0,#1
0000ec  4918              LDR      r1,|L2.336|
0000ee  6989              LDR      r1,[r1,#0x18]  ; PowerRecordObj
0000f0  fb90f0f1          SDIV     r0,r0,r1
0000f4  4916              LDR      r1,|L2.336|
0000f6  6148              STR      r0,[r1,#0x14]  ; PowerRecordObj
;;;493    
;;;494    #if  defined(__DEL_BELOW_05_W__)
;;;495    	if(500 > PowerRecordObj[0].record_ValidPower) 
0000f8  4608              MOV      r0,r1
0000fa  6940              LDR      r0,[r0,#0x14]  ; PowerRecordObj
0000fc  f5b07ffa          CMP      r0,#0x1f4
000100  da01              BGE      |L2.262|
;;;496    	{
;;;497    	    PowerRecordObj[0].record_ValidPower = 0;
000102  2000              MOVS     r0,#0
000104  6148              STR      r0,[r1,#0x14]  ; PowerRecordObj
                  |L2.262|
;;;498    	}
;;;499    #endif 
;;;500    
;;;501    	if(0x00 == SwInformation.PortInfor[0].CurStatus)
000106  4813              LDR      r0,|L2.340|
000108  7e00              LDRB     r0,[r0,#0x18]
00010a  b940              CBNZ     r0,|L2.286|
;;;502    	{
;;;503    	    PowerRecordObj[0].record_ValidCurrent = 0; 
00010c  2000              MOVS     r0,#0
00010e  4910              LDR      r1,|L2.336|
000110  6048              STR      r0,[r1,#4]  ; PowerRecordObj
;;;504    	    PowerRecordObj[0].record_ValidVolt    = 0; 
000112  60c8              STR      r0,[r1,#0xc]  ; PowerRecordObj
;;;505    	    PowerRecordObj[0].record_ValidPower   = 0; 
000114  6148              STR      r0,[r1,#0x14]  ; PowerRecordObj
;;;506    
;;;507    	    reco_measure_data.reco_irms        = 0;
000116  490d              LDR      r1,|L2.332|
000118  6008              STR      r0,[r1,#0]  ; reco_measure_data
;;;508    	    reco_measure_data.reco_urms        = 0;
00011a  6048              STR      r0,[r1,#4]  ; reco_measure_data
;;;509    	    reco_measure_data.reco_powerp      = 0;
00011c  60c8              STR      r0,[r1,#0xc]  ; reco_measure_data
                  |L2.286|
;;;510    	}
;;;511    
;;;512    	if(PowerRecordObj[0].record_ValidPower < 4000000)
00011e  480c              LDR      r0,|L2.336|
000120  6940              LDR      r0,[r0,#0x14]  ; PowerRecordObj
000122  490d              LDR      r1,|L2.344|
000124  4288              CMP      r0,r1
000126  da0e              BGE      |L2.326|
;;;513    	{
;;;514    		TempPowerStaticsSum[0]             += PowerRecordObj[0].record_ValidPower/10; 
000128  4809              LDR      r0,|L2.336|
00012a  6940              LDR      r0,[r0,#0x14]  ; PowerRecordObj
00012c  210a              MOVS     r1,#0xa
00012e  fb90f0f1          SDIV     r0,r0,r1
000132  490a              LDR      r1,|L2.348|
000134  6809              LDR      r1,[r1,#0]  ; TempPowerStaticsSum
000136  4408              ADD      r0,r0,r1
000138  4908              LDR      r1,|L2.348|
00013a  6008              STR      r0,[r1,#0]  ; TempPowerStaticsSum
;;;515    		readPowerCount++;
00013c  4808              LDR      r0,|L2.352|
00013e  6800              LDR      r0,[r0,#0]  ; readPowerCount
000140  1c40              ADDS     r0,r0,#1
000142  4907              LDR      r1,|L2.352|
000144  6008              STR      r0,[r1,#0]  ; readPowerCount
                  |L2.326|
;;;516    	}
;;;517    
;;;518    #if 0	
;;;519    	if(readPowerCount%5 == 0)
;;;520    	{
;;;521    		memset(testBuffer,0,sizeof(testBuffer));
;;;522     		sprintf(testBuffer,"power=%d\t	sumPower=%d\t readPowerCount=%d\n",
;;;523     				PowerRecordObj[0].record_ValidPower,TempPowerStaticsSum[0],readPowerCount);
;;;524    		UdpDebugPrint(testBuffer,strlen(testBuffer));
;;;525    	}
;;;526     #endif
;;;527    }
000146  b007              ADD      sp,sp,#0x1c
000148  bd00              POP      {pc}
;;;528    
                          ENDP

00014a  0000              DCW      0x0000
                  |L2.332|
                          DCD      reco_measure_data
                  |L2.336|
                          DCD      PowerRecordObj
                  |L2.340|
                          DCD      SwInformation
                  |L2.344|
                          DCD      0x003d0900
                  |L2.348|
                          DCD      TempPowerStaticsSum
                  |L2.352|
                          DCD      readPowerCount

                          AREA ||i.Read_Rn8209_deviceID||, CODE, READONLY, ALIGN=1

                  Read_Rn8209_deviceID PROC
;;;535    *******************************************************************************/
;;;536    int Read_Rn8209_deviceID(void)
000000  b500              PUSH     {lr}
;;;537    {
000002  b087              SUB      sp,sp,#0x1c
;;;538    	SpiPack         R8209Framemain;
;;;539    	unsigned char   recvdata[10] = {0};
000004  2000              MOVS     r0,#0
000006  9001              STR      r0,[sp,#4]
000008  9002              STR      r0,[sp,#8]
00000a  9003              STR      r0,[sp,#0xc]
;;;540    	
;;;541        #if (defined(__CARIBRATION_POWER_COEFFICIENT_DBG__) || defined(__RN8209_SPI_DBG__)) && defined(__UDP_PRINT_DBG__)
;;;542    	int             *pS32Buf;
;;;543        int             iLength;
;;;544        char            DbgMsgArr[60] = {0};
;;;545        #endif 
;;;546    	
;;;547    	R8209Framemain.spi_Address      = RN8209_DeviceID;                 // deviceID
00000c  207f              MOVS     r0,#0x7f
00000e  f88d0010          STRB     r0,[sp,#0x10]
;;;548    	R8209Framemain.spi_Data         = (unsigned char *)&recvdata;
000012  a801              ADD      r0,sp,#4
000014  9005              STR      r0,[sp,#0x14]
;;;549    	R8209Framemain.spi_NumberOfByte = RN8209_DeviceID_Length;
000016  2003              MOVS     r0,#3
000018  f88d0018          STRB     r0,[sp,#0x18]
;;;550    	SpiRn8209_ReadFrame(&R8209Framemain);
00001c  a804              ADD      r0,sp,#0x10
00001e  f7fffffe          BL       SpiRn8209_ReadFrame
;;;551    
;;;552        #if (defined(__CARIBRATION_POWER_COEFFICIENT_DBG__) || defined(__RN8209_SPI_DBG__)) && defined(__UDP_PRINT_DBG__)
;;;553        pS32Buf = (int*)&recvdata[0];
;;;554        iLength = sprintf(DbgMsgArr,"8209G-DeviceID:[%02x][%02x][%02x]--%08x\r\n",
;;;555                                    recvdata[2], recvdata[1], recvdata[0], *pS32Buf);
;;;556        UdpDebugPrint(DbgMsgArr, iLength); 
;;;557        #endif 
;;;558    	if((0x82==recvdata[2]) && (0x09==recvdata[1]) && (0x00==recvdata[0]))
000022  f89d0006          LDRB     r0,[sp,#6]
000026  2882              CMP      r0,#0x82
000028  d109              BNE      |L3.62|
00002a  f89d0005          LDRB     r0,[sp,#5]
00002e  2809              CMP      r0,#9
000030  d105              BNE      |L3.62|
000032  f89d0004          LDRB     r0,[sp,#4]
000036  b910              CBNZ     r0,|L3.62|
;;;559    	{
;;;560    	    return 0;
000038  2000              MOVS     r0,#0
                  |L3.58|
;;;561    	}
;;;562    	return 1;
;;;563    }
00003a  b007              ADD      sp,sp,#0x1c
00003c  bd00              POP      {pc}
                  |L3.62|
00003e  2001              MOVS     r0,#1                 ;562
000040  e7fb              B        |L3.58|
;;;564    /*******************************************************************************
                          ENDP


                          AREA ||i.ZX_detect_control||, CODE, READONLY, ALIGN=2

                  ZX_detect_control PROC
;;;219    extern uint8_t zxMark;
;;;220    void ZX_detect_control(void)
000000  b510              PUSH     {r4,lr}
;;;221    {
;;;222    	hfthread_suspend_all();
000002  f7fffffe          BL       hfthread_suspend_all
;;;223    
;;;224    	if(plug_updata)
000006  4810              LDR      r0,|L4.72|
000008  7800              LDRB     r0,[r0,#0]  ; plug_updata
00000a  b1d0              CBZ      r0,|L4.66|
;;;225        {			
;;;226    
;;;227    		if(SwInformation.PortInfor[0].CurStatus)
00000c  480f              LDR      r0,|L4.76|
00000e  7e00              LDRB     r0,[r0,#0x18]
000010  b150              CBZ      r0,|L4.40|
;;;228            {
;;;229    			delay_us(delay_onTime);
000012  480f              LDR      r0,|L4.80|
000014  6800              LDR      r0,[r0,#0]  ; delay_onTime
000016  f7fffffe          BL       delay_us
;;;230                hfgpio_fset_out_high(SwitchPinArr[0]);               // On          
00001a  490e              LDR      r1,|L4.84|
00001c  6808              LDR      r0,[r1,#0]  ; SwitchPinArr
00001e  f04f5100          MOV      r1,#0x20000000
000022  f7fffffe          BL       hfgpio_configure_fpin
000026  e009              B        |L4.60|
                  |L4.40|
;;;231            }
;;;232            else
;;;233            {
;;;234    			delay_us(delay_offTime);
000028  480b              LDR      r0,|L4.88|
00002a  6800              LDR      r0,[r0,#0]  ; delay_offTime
00002c  f7fffffe          BL       delay_us
;;;235                hfgpio_fset_out_low(SwitchPinArr[0]);                // Off 
000030  4908              LDR      r1,|L4.84|
000032  6808              LDR      r0,[r1,#0]  ; SwitchPinArr
000034  f04f5180          MOV      r1,#0x10000000
000038  f7fffffe          BL       hfgpio_configure_fpin
                  |L4.60|
;;;236            }
;;;237    		
;;;238    		plug_updata = 0;
00003c  2000              MOVS     r0,#0
00003e  4902              LDR      r1,|L4.72|
000040  7008              STRB     r0,[r1,#0]
                  |L4.66|
;;;239    
;;;240        }
;;;241    	hfthread_resume_all();
000042  f7fffffe          BL       hfthread_resume_all
;;;242    
;;;243    }
000046  bd10              POP      {r4,pc}
;;;244    #endif
                          ENDP

                  |L4.72|
                          DCD      plug_updata
                  |L4.76|
                          DCD      SwInformation
                  |L4.80|
                          DCD      delay_onTime
                  |L4.84|
                          DCD      SwitchPinArr
                  |L4.88|
                          DCD      delay_offTime

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  reco_measure_data
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  plug_updata
000000  00                DCB      0x00
                  giveDelayValue
000001  000000            DCB      0x00,0x00,0x00
                  delay_onTime
                          DCD      0x00002af8
                  delay_offTime
                          DCD      0x00001388
